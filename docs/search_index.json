[
["index.html", "Applied Statistics II Preface", " Applied Statistics II Robin A. Donatello and Edward A. Roualdes Last Updated 2018-01-25 Preface This document is a set of course notes for Math 456 - Applied Statistics II at California State University, Chico. This is not a textbook replacement, and topics covered will vary depending on the instructor. To make this clear we use the term notebook to refer to this document so as not to be confused with a traditional textbook. Some data and examples in this notebook are drawn from Practical Multivariate Analysis, 5th ed, Afifi, May, Clark and used with permission by the authors. This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License. "],
["data-prep.html", "Chapter 1 Preparing Data for Analysis", " Chapter 1 Preparing Data for Analysis Write an introduction here. "],
["reproducible-workflows.html", "1.1 Reproducible Workflows", " 1.1 Reproducible Workflows PrepareData Why do we need a codebook? You are your own collaborator 6 months from now. Make sure you will be able to understand what you were doing. Investing the time to do things clearly and in a reproducible manner will make your future self happy. Comment your code with explanations and instructions. How did you get from point A to B? Why did you recode this variable in this manner? Repro Figure Credits: Roger Peng What stages of this pipeline can we conduct using R Markdown? "],
["identifying-variable-types.html", "1.2 Identifying Variable Types", " 1.2 Identifying Variable Types This section uses the raw depression data set from Afifi et.al. depress &lt;- read.table(&quot;https://norcalbiostat.netlify.com/data/Depress.txt&quot;, sep=&quot;\\t&quot;, header=TRUE) Consider a variable that measures marital status. table(depress$MARITAL) ## ## 1 2 3 4 5 ## 73 127 43 13 38 str(depress$MARITAL) ## int [1:294] 5 3 2 3 4 2 2 1 2 2 ... class(depress$MARITAL) ## [1] &quot;integer&quot; What data type does R see this variable as? When variables have numerical levels it is necessary to ensure that R knows it is a factor variable. The following code uses the factor() function to take the marital status variable and convert it into a factor variable with specified labels that match the codebook. depress$MARITAL &lt;- factor(depress$MARITAL, labels = c(&quot;Never Married&quot;, &quot;Married&quot;, &quot;Divorced&quot;, &quot;Separated&quot;, &quot;Widowed&quot;)) It is important to confirm the recode worked. If it did not you will have to re-read in the raw data set again since the variable SEX was replaced. table(depress$MARITAL) ## ## Never Married Married Divorced Separated Widowed ## 73 127 43 13 38 class(depress$MARITAL) ## [1] &quot;factor&quot; Create a boxplot of income across marital status category. qplot(y=INCOME, x=MARITAL, data=depress, geom=&quot;boxplot&quot;) Boxplots are nice because they clearly show the range where 50% of the data lie and any potential outliers. Boxplots can also indicate skewness, but sometimes it is helpful to visualize the location of the mean as well as the median. ggplot2 has a nice stat_summary layer that will calculate and add the means to the current plot. qplot(y=INCOME, x=MARITAL, data=depress, geom=&quot;boxplot&quot;) + stat_summary(fun.y=mean, colour=&quot;blue&quot;, size=3, geom=&quot;point&quot;) "],
["data-editing-and-recoding.html", "1.3 Data Editing and Recoding", " 1.3 Data Editing and Recoding For unbiased and accurate results of a statistical analysis, sufficient data has to be present. Often times once you start slicing and dicing the data to only look at certain groups, or if you are interested in the behavior of certain variables across levels of another variable, sometimes you start to run into small sample size problems. For example, consider marital status again: table(depress$MARITAL) ## ## Never Married Married Divorced Separated Widowed ## 73 127 43 13 38 There are only 13 people who report being separated. This could potentially be too small of a group size for valid statistical analysis. One way to deal with insufficient data within a certain category is to collapse categories. The following code uses the recode() function from the car package to create a new variable that I am calling MARITAL2 that combines the Divorced and Separated levels. depress$MARITAL2 &lt;- car::recode(depress$MARITAL, &quot;&#39;Divorced&#39; = &#39;Sep/Div&#39;; &#39;Separated&#39; = &#39;Sep/Div&#39;&quot;) What does the double colon :: notation in car::recode do, and why is this tactic beneficial? Always confirm your recodes. table(depress$MARITAL, depress$MARITAL2, useNA=&quot;always&quot;) ## ## Married Never Married Sep/Div Widowed &lt;NA&gt; ## Never Married 0 73 0 0 0 ## Married 127 0 0 0 0 ## Divorced 0 0 43 0 0 ## Separated 0 0 13 0 0 ## Widowed 0 0 0 38 0 ## &lt;NA&gt; 0 0 0 0 0 This confirms that records where MARITAL (rows) is Divorced or Separated have the value of Sep/Div for MARITAL2 (columns). Now let’s examine the relationship between income against marital status by creating a boxplot. This is a situation where jittering or dodging the points is helpful to avoid overplotting of points. Note that the full ggplot code had to be used here, not the simpler qplot methods. Furthermore, the grid.arrange function from the gridExtra package is used to display these plots side by side. library(gridExtra) a &lt;- qplot(x=MARITAL2, y=INCOME, data=depress, col=MARITAL2, geom=&quot;point&quot;, main = &quot;Without jittering&quot;) + coord_flip() + theme(legend.position=&quot;none&quot;) b &lt;- ggplot(depress, aes(x=INCOME, y=MARITAL2, color=MARITAL2), main=&quot;With jittering&quot;) + geom_point(position=position_jitter()) + theme(legend.position=&quot;none&quot;) grid.arrange(a, b, ncol=2) What do you think coord_flip() does? Look at the difference in the X and Y values between plot a and plot b. What do you think theme(legend.position=&quot;none&quot;) does? What can you say about the relationship between Income and marital status? "],
["outliers.html", "1.4 Outliers", " 1.4 Outliers Let’s look at the age variable in the depression data set. par(mfrow=c(1,2)) boxplot(depress$AGE) hist(depress$AGE) Just looking at the data graphically raises no red flags. The boxplot shows no outlying values and the histogram does not look wildly skewed. This is where knowledge about the data set is essential. The codebook does not provide a valid range for the data, but the description of the data starting on page 3 in the textbook clarifies that this data set is on adults. In the research world, this specifies 18 years or older. Now look back at the graphics. See anything odd? It appears as if the data go pretty far below 20, possibly below 18. Let’s check the numerical summary to get more details. summary(depress$AGE) ## Min. 1st Qu. Median Mean 3rd Qu. Max. ## 9.00 28.00 42.50 44.38 59.00 89.00 The minimum value is a 9, which is outside the range of valid values for this variable. This is where you, as a statistician, data analyst or researcher goes back to the PI and asks for advice. Should this data be set to missing, or edited in a way that changes this data point into a valid piece of data. As an example of a common data entry error, and for demonstration purposes, I went in and changed a 19 to a 9. So the correct thing to do here is to change that 9, back to a 19. This is a very good use of the ifelse() function. depress$AGE &lt;- ifelse(depress$AGE==9, 19, depress$AGE) The logical statement is depress$AGE==9. Wherever this is true, replace the value of depress$AGE with 19, wherever this is false then keep the value of depress$AGE unchanged (by “replacing” the new value with the same old value). Alternatively, you can change that one value using bracket notation. Here you are specifying that you only want the rows where AGE==9, and directly assign a value of 19 to those rows. depress$AGE[depress$AGE==9] &lt;- 19 Confirm the recode. summary(depress$AGE) ## Min. 1st Qu. Median Mean 3rd Qu. Max. ## 18.00 28.00 42.50 44.41 59.00 89.00 Looks like it worked. "],
["data-transformations.html", "1.5 Data Transformations", " 1.5 Data Transformations Let’s look at assessing normal distributions using the cleaned depression data set. rm(depress) # remove the current version that was used in the previous part of this markdown file depress &lt;- read.table(&quot;https://norcalbiostat.netlify.com/data/depress_081217.txt&quot;, sep=&quot;\\t&quot;, header=TRUE) hist(depress$INCOME, prob=TRUE, xlab=&quot;Annual income (in thousands)&quot;, main=&quot;Histogram and Density curve of Income&quot;, ylab=&quot;&quot;) lines(density(depress$INCOME), col=&quot;blue&quot;) summary(depress$INCOME) ## Min. 1st Qu. Median Mean 3rd Qu. Max. ## 2.00 9.00 15.00 20.57 28.00 65.00 The distribution of annual income is slightly skewed right with a mean of $20.5k per year and a median of $15k per year income. The range of values goes from $2k to $65k. Reported income above $40k appear to have been rounded to the nearest $10k, because there are noticeable peaks at $40k, $50k, and $60k. In general, transformations are more effective when the the standard deviation is large relative to the mean. One rule of thumb is if the sd/mean ratio is less than 1/4, a transformation may not be necessary. sd(depress$INCOME) / mean(depress$INCOME) ## [1] 0.743147 Alternatively Hoaglin, Mosteller and Tukey (1985) showed that if the largest observation divided by the smallest observation is over 2, then the data may not be sufficiently variable for the transformation to be decisive. max(depress$INCOME) / (min(depress$INCOME)+.1) ## [1] 30.95238 Note these rules are not meaningful for data without a natural zero. Another common method of assessing normality is to create a normal probability (or normal quantile) plot. qqnorm(depress$INCOME);qqline(depress$INCOME, col=&quot;red&quot;) The points on the normal probability plot do not follow the red reference line very well. The dots show a more curved, or U shaped form rather than following a linear line. This is another indication that the data is skewed and a transformation for normality should be created. Create three new variables: log10inc as the log base 10 of Income, loginc as the natural log of Income, and xincome which is equal to the negative of one divided by the cubic root of income. log10inc &lt;- log10(depress$INCOME) loginc &lt;- log(depress$INCOME) xincome &lt;- -1/(depress$INCOME)^(-1/3) Create a single plot that display normal probability plots for the original, and each of the three transformations of income. Use the base graphics grid organizer par(mfrow=c(r,c)) where r is the number of rows and c is the number of columns. Which transformation does a better job of normalizing the distribution of Income? par(mfrow=c(2,2)) # Try (4,1) and (1,4) to see how this works. qqnorm(depress$INCOME, main=&quot;Income&quot;); qqline(depress$INCOME,col=&quot;blue&quot;) qqnorm(log10inc, main=&quot;Log 10&quot;); qqline(log10inc, col=&quot;blue&quot;) qqnorm(loginc, main = &quot;Natural Log&quot;); qqline(loginc, col=&quot;blue&quot;) qqnorm(xincome, main=&quot;-1/cuberoot(income)&quot;); qqline(xincome, col=&quot;blue&quot;) "],
["selecting-appropriate-analysis.html", "1.6 Selecting Appropriate Analysis", " 1.6 Selecting Appropriate Analysis Considerations: Purpose of analysis. Types of variables in data set. Data used in analysis. Assumptions needed; satisfied? Choice of analyses is often arbitrary: consider several Example: 5 independent variables: 3 interval, 1 ordinal, 1 nominal 1 dependent variable: interval Analysis options Multiple regression: pretend independent ordinal variable is an interval variable use dummy (0 /1) variables for nominal variables Analysis of variance: categorize all independent variables Analysis of covariance: leave variables as is, check assumptions Logistic regression: Categorize dependent variable: high, low Survival analysis: IF dependent variable is time to an event Unsure? Do several and compare results. "],
["wide-vs-long-data.html", "1.7 Wide vs. Long data", " 1.7 Wide vs. Long data The data on Lung function originally was recorded in wide format, with separate variables for mother’s and father’s FEV1 score (MFEV1 and FFEV). In this format, the data is one record per family. fev &lt;- read.delim(&quot;https://norcalbiostat.netlify.com/data/Lung_081217.txt&quot;, sep=&quot;\\t&quot;, header=TRUE) head(fev) ## ID AREA FSEX FAGE FHEIGHT FWEIGHT FFVC FFEV1 MSEX MAGE MHEIGHT MWEIGHT ## 1 1 1 1 53 61 161 391 3.23 2 43 62 136 ## 2 2 1 1 40 72 198 441 3.95 2 38 66 160 ## 3 3 1 1 26 69 210 445 3.47 2 27 59 114 ## 4 4 1 1 34 68 187 433 3.74 2 36 58 123 ## 5 5 1 1 46 61 121 354 2.90 2 39 62 128 ## 6 6 1 1 44 72 153 610 4.91 2 36 66 125 ## MFVC MFEV1 OCSEX OCAGE OCHEIGHT OCWEIGHT OCFVC OCFEV1 MCSEX MCAGE ## 1 370 3.31 2 12 59 115 296 2.79 NA NA ## 2 411 3.47 1 10 56 66 323 2.39 NA NA ## 3 309 2.65 1 8 50 59 114 1.11 NA NA ## 4 265 2.06 2 11 57 106 256 1.85 1 9 ## 5 245 2.33 1 16 61 88 260 2.47 2 12 ## 6 349 3.06 1 15 67 100 389 3.55 1 13 ## MCHEIGHT MCWEIGHT MCFVC MCFEV1 YCSEX YCAGE YCHEIGHT YCWEIGHT YCFVC ## 1 NA NA NA NA NA NA NA NA NA ## 2 NA NA NA NA NA NA NA NA NA ## 3 NA NA NA NA NA NA NA NA NA ## 4 49 56 159 1.30 NA NA NA NA NA ## 5 60 85 268 2.34 2 10 50 53 154 ## 6 57 87 276 2.37 2 10 55 72 195 ## YCFEV1 ## 1 NA ## 2 NA ## 3 NA ## 4 NA ## 5 1.43 ## 6 1.69 To analyze the effect of gender on FEV, the data need to be in long format, with a single variable for FEV and a separate variable for gender. The following code chunk demonstrates one method of combining data on height, gender, age and FEV1 for both males and females. fev2 &lt;- data.frame(gender = c(fev$FSEX, fev$MSEX), FEV = c(fev$FFEV1, fev$MFEV1), ht = c(fev$FHEIGHT, fev$MHEIGHT), age = c(fev$FAGE, fev$MAGE)) fev2$gender &lt;- factor(fev2$gender, labels=c(&quot;M&quot;, &quot;F&quot;)) head(fev2) ## gender FEV ht age ## 1 M 3.23 61 53 ## 2 M 3.95 72 40 ## 3 M 3.47 69 26 ## 4 M 3.74 68 34 ## 5 M 2.90 61 46 ## 6 M 4.91 72 44 Nearly all analysis procedures and most graphing procedures require the data to be in long format. There are several R packages that can help with this including reshape2 and tidyr. Educational researchers might want to learn about the best predictors of success in high-school. Sociologists may want to find out which of the multiple social indicators best predict whether or not a new immigrant group will adapt to their new country of residence. Biologists may want to find out which factors (i.e. temperature, barometric pressure, humidity, etc.) best predict caterpillar reproduction. This chapter starts by recapping notation and topics for simple linear regression, when there is only one predictor. Then we move into generalization of these concepts to many predictors, and model building topics such as stratification, interactions, and categorical predictors. "],
["simple-linear-regression.html", "Chapter 2 Simple Linear Regression", " Chapter 2 Simple Linear Regression The goal of linear regression is to Describe the relationship between an independent variable X and a continuous dependent variable \\(Y\\) as a straight line. The textbook discusses two cases: Fixed-\\(X\\): values of \\(X\\) are preselected by investigator Variable-\\(X\\): have random sample of \\((X,Y)\\) values Calculations are the same, Draw inferences regarding this relationship Predict value of \\(Y\\) for a given value of \\(X\\) "],
["mathmatical-model.html", "2.1 Mathmatical Model", " 2.1 Mathmatical Model The mean of \\(Y\\) values at any given \\(X\\) is \\(\\beta_{0} + \\beta_{1} X\\) The variance of \\(Y\\) values at any \\(X\\) is \\(\\sigma^2\\) (same for all X) \\(Y\\) values are normally distributed at any given \\(X\\) (need for inference) Figure 6.2 "],
["parameter-estimates.html", "2.2 Parameter Estimates", " 2.2 Parameter Estimates Estimate the slope \\(\\beta_{1}\\) and intercept \\(\\beta_{0}\\) using least-squares methods. The residual mean squared error (RMSE) is an estimate of the variance \\(s^{2}\\) Typically interested in inference on \\(\\beta_{1}\\) Assume no relationship between \\(X\\) and \\(Y\\) \\((H_{0}: \\beta_{1}=0)\\) until there is reason to believe there is one \\((H_{0}: \\beta_{1} \\neq 0)\\) "],
["interval-estimation.html", "2.3 Interval estimation", " 2.3 Interval estimation Everything is estimated with some degree of error Confidence intervals for the mean of \\(Y\\) Prediction intervals for an individual \\(Y\\) Which one is wider? Why? "],
["corelation-coefficient.html", "2.4 Corelation Coefficient", " 2.4 Corelation Coefficient The correlation coefficient \\(\\rho\\) measures the strength of association between \\(X\\) and \\(Y\\) in the population. \\(\\sigma^{2} = VAR(Y|X)\\) is the variance of \\(Y\\) for a specific \\(X\\). \\(\\sigma_{y}^{2} = VAR(Y)\\) is the variance of \\(Y\\) for all \\(X\\)’s. \\[ \\sigma^{2} = \\sigma_{y}^{2}(1-\\rho^{2})\\] \\[ \\rho^{2} = \\frac{\\sigma_{y}^{2} - \\sigma^{2}}{\\sigma_{y}^{2}}\\] \\(\\rho^{2}\\) = reduction in variance of Y associated with knowledge of X/original variance of Y Coefficient of Determiniation: \\(100\\rho^{2}\\) = % of variance of Y associated with X or explained by X Caution: association vs. causation. "],
["assumptions.html", "2.5 Assumptions", " 2.5 Assumptions Homogeneity of variance (same \\(\\sigma^{2}\\)) Not extremely serious Can use transformations to achieve it Graphical assessment: Plot the residuals against the x variable, add a lowess line. This assumption is upheld if there is no relationship/trend between the residuals and the predictor. Normal residuals Slight departures OK Can use transformations to achieve it Graphical assessment: normal qqplot of the model residuals. Randomness / Independence Very serious Can use hierarchical models for clustered samples No real good way to “test” for independence. Need to know how the sample was obtained. Linear relationship Slight departures OK Can use transformations to achieve it Graphical assessment: Simple scatterplot of \\(y\\) vs \\(x\\). Looking for linearity in the relationship. Should be done prior to any analysis. "],
["example.html", "2.6 Example", " 2.6 Example Using a cleaned version of the Lung function data set, lets explore the relationship between height and FEV for fathers in this data set. fev &lt;- read.delim(&quot;https://norcalbiostat.netlify.com/data/Lung_081217.txt&quot;, sep=&quot;\\t&quot;, header=TRUE) qplot(y=FFEV1, x=FHEIGHT, geom=&quot;point&quot;, data=fev, xlab=&quot;Height&quot;, ylab=&quot;FEV1&quot;, main=&quot;Scatter Diagram with Regression (blue) and Lowess (red) Lines of FEV1 Versus Height for Fathers.&quot;) + geom_smooth(method=&quot;lm&quot;, se=FALSE, col=&quot;blue&quot;) + geom_smooth(se=FALSE, col=&quot;red&quot;) There does appear to be a tendency for taller men to have higher FEV1. Let’s fit a linear model and report the regression parameter estimates. model &lt;- lm(FFEV1 ~ FHEIGHT, data=fev) summary(model) ## ## Call: ## lm(formula = FFEV1 ~ FHEIGHT, data = fev) ## ## Residuals: ## Min 1Q Median 3Q Max ## -1.56688 -0.35290 0.04365 0.34149 1.42555 ## ## Coefficients: ## Estimate Std. Error t value Pr(&gt;|t|) ## (Intercept) -4.08670 1.15198 -3.548 0.000521 *** ## FHEIGHT 0.11811 0.01662 7.106 4.68e-11 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## Residual standard error: 0.5638 on 148 degrees of freedom ## Multiple R-squared: 0.2544, Adjusted R-squared: 0.2494 ## F-statistic: 50.5 on 1 and 148 DF, p-value: 4.677e-11 The least squares equation is \\(Y = -4.087 + 0.118X\\). confint(model) ## 2.5 % 97.5 % ## (Intercept) -6.36315502 -1.8102499 ## FHEIGHT 0.08526328 0.1509472 For ever inch taller a father is, his FEV1 measurement significantly increases by .12 (95%CI: .09, .15, p&lt;.0001). The correlation between FEV1 and height is \\(\\sqrt{.2544}\\) = 0.5. Lastly, check assumptions on the residuals to see if the model results are valid. Homogeneity of variance plot(model$residuals ~ fev$FHEIGHT) lines(lowess(model$residuals ~ fev$FHEIGHT), col=&quot;red&quot;) Normal residuals qqnorm(model$residuals) qqline(model$residuals, col=&quot;red&quot;) No major deviations away from what is expected. "],
["multiple-linear-regression.html", "Chapter 3 Multiple Linear Regression", " Chapter 3 Multiple Linear Regression Extends simple linear regression. Describes a linear relationship between a single continuous \\(Y\\) variable, and several \\(X\\) variables. Predicts \\(Y\\) from \\(X_{1}, X_{2}, \\ldots , X_{P}\\). Now it’s no longer a 2D regression line, but a \\(p\\) dimensional regression plane. "],
["types-of-x-variables.html", "3.1 Types of X variables", " 3.1 Types of X variables Fixed: The levels of \\(X\\) are selected in advance with the intent to measure the affect on an outcome \\(Y\\). Variable: Random sample of individuals from the population is taken and \\(X\\) and \\(Y\\) are measured on each individual. X’s can be continuous or discrete (categorical) X’s can be transformations of other X’s, e.g., \\(log(x), x^{2}\\). "],
["mathematical-model.html", "3.2 Mathematical Model", " 3.2 Mathematical Model \\[ y_{i} = \\beta_{0} + \\beta_{1}x_{1i} + \\ldots + \\beta_{p}x_{pi} + \\epsilon_{i}\\] The assumptions on the residuals \\(\\epsilon_{i}\\) still hold: They have mean zero They are homoscedastic, that is all have the same finite variance: \\(Var(\\epsilon_{i})=\\sigma^{2}&lt;\\infty\\) Distinct error terms are uncorrelated: (Independent) \\(\\text{Cov}(\\epsilon_{i},\\epsilon_{j})=0,\\forall i\\neq j.\\) The regression model relates \\(y\\) to a function of \\(\\textbf{X}\\) and \\(\\mathbf{\\beta}\\), where \\(\\textbf{X}\\) is a \\(nxp\\) matrix of \\(p\\) covariates on \\(n\\) observations and \\(\\mathbf{\\beta}\\) is a length \\(p\\) vector of regression coefficients. In matrix notation this looks like: \\[ \\textbf{y} = \\textbf{X} \\mathbf{\\beta} + \\mathbf{\\epsilon} \\] "],
["parameter-estimation.html", "3.3 Parameter Estimation", " 3.3 Parameter Estimation The goal of regression analysis is to minimize the residual error. That is, to minimize the difference between the value of the dependent variable predicted by the model and the true value of the dependent variable. \\[ \\epsilon_{i} = \\hat{y_{i}} - y_{i}\\] The method of Least Squares accomplishes this by finding parameter estimates \\(\\beta_{0}\\) and \\(\\beta_{1}\\) that minimized the sum of the squared residuals: \\[ \\sum_{i=1}^{n} \\epsilon_{i} \\] For simple linear regression the regression coefficient estimates that minimize the sum of squared errors can be calculated as: \\[ \\hat{\\beta_{0}} = \\bar{y} - \\hat{\\beta_{1}}\\bar{x} \\quad \\mbox{ and } \\quad \\hat{\\beta_{1}} = r\\frac{s_{y}}{s_{x}} \\] For multiple linear regression, the fitted values \\(\\hat{y_{i}}\\) are calculated as the linear combination of x’s and \\(\\beta\\)’s, \\(\\sum_{i=1}^{p}X_{ij}\\beta_{j}\\). The sum of the squared residual errors (the distance between the observed point \\(y_{i}\\) and the fitted value) now has the following form: \\[ \\sum_{i=1}^{n} |y_{i} - \\sum_{i=1}^{p}X_{ij}\\beta_{j}|^{2}\\] Or in matrix notation \\[ || \\mathbf{y} - \\mathbf{X}\\mathbf{\\beta} ||^{2} \\] The details of methods to calculate the Least Squares estimate of \\(\\beta\\)’s is left to a course in mathematical statistics. "],
["example-1.html", "3.4 Example", " 3.4 Example The analysis in example (???) concluded that FEV1 in fathers significantly increases by 0.12 (95% CI:0.09, 0.15) liters per additional inch in height (p&lt;.0001). Looking at the multiple \\(R^{2}\\) (correlation of determination), this simple model explains 25% of the variance seen in the outcome \\(y\\). However, FEV tends to decrease with age for adults, so we should be able to predict it better if we use both height and age as independent variables in a multiple regression equation. What direction do you expect the slope coefficient for age to be? For height? Fitting a regression model in R with more than 1 predictor is done by adding each variable to the right hand side of the model notation connected with a +. mv_model &lt;- lm(FFEV1 ~ FAGE + FHEIGHT, data=fev) summary(mv_model) ## ## Call: ## lm(formula = FFEV1 ~ FAGE + FHEIGHT, data = fev) ## ## Residuals: ## Min 1Q Median 3Q Max ## -1.34708 -0.34142 0.00917 0.37174 1.41853 ## ## Coefficients: ## Estimate Std. Error t value Pr(&gt;|t|) ## (Intercept) -2.760747 1.137746 -2.427 0.0165 * ## FAGE -0.026639 0.006369 -4.183 4.93e-05 *** ## FHEIGHT 0.114397 0.015789 7.245 2.25e-11 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## Residual standard error: 0.5348 on 147 degrees of freedom ## Multiple R-squared: 0.3337, Adjusted R-squared: 0.3247 ## F-statistic: 36.81 on 2 and 147 DF, p-value: 1.094e-13 confint(mv_model) ## 2.5 % 97.5 % ## (Intercept) -5.00919751 -0.51229620 ## FAGE -0.03922545 -0.01405323 ## FHEIGHT 0.08319434 0.14559974 Holding height constant, a father who is one year older is expected to have a FEV value 0.03 (0.01, 0.04) liters less than another man (p&lt;.0001). Holding height constant, a father who is 1cm taller than another man is expected to have a FEV value of 0.11 (.08, 0.15) liter greater than the other man (p&lt;.0001). For the model that includes age, the coefficient for height is now 0.11, which is interpreted as the rate of change of FEV1 as a function of height after adjusting for age. This is also called the partial regression coefficient of FEV1 on height after adjusting for age. Both height and age are significantly associated with FEV in fathers (p&lt;.0001 each). "],
["model-diagnostics.html", "3.5 Model Diagnostics", " 3.5 Model Diagnostics The same set of regression diagnostics can be examined to identify any potential influential points, outliers or other problems with the linear model. par(mfrow=c(2,2)) plot(mv_model) "],
["multicollinearity.html", "3.6 Multicollinearity", " 3.6 Multicollinearity Occurs when some of the X variables are highly intercorrelated. Affects estimates and their SE’s (p. 143) Look at tolerance, and its inverse, the Variance Inflation Factor (VIF) Need tolerance &lt; 0.01, or VIF &gt; 100. car::vif(mv_model) ## FAGE FHEIGHT ## 1.003163 1.003163 tolerance = 1/car::vif(mv_model) tolerance ## FAGE FHEIGHT ## 0.9968473 0.9968473 Solution: use variable selection to delete some X variables. Alternatively, use dimension reduction techniques such as Principal Components "],
["what-to-watch-out-for.html", "3.7 What to watch out for", " 3.7 What to watch out for Representative sample Range of prediction should match observed range of X in sample Use of nominal or ordinal, rather than interval or ratio data Errors-in-variables Correlation does not imply causation Violation of assumptions Influential points Appropriate model Multicollinearity "],
["model-building.html", "Chapter 4 Model Building", " Chapter 4 Model Building Model building methods are used mainly in exploratory situations where many independent variables have been measured, but a final model explaining the dependent variable has not been reached. You want to build a model that contains enough covariates to explain the model well, but still be parsimonious such that the model is still interpretable. This chapter introduces different types of covariates that can be used, stratified models, confounding and moderation. We then conclude with measures of model fit and methods to compare between competing models. "],
["categorical-predictors.html", "4.1 Categorical Predictors", " 4.1 Categorical Predictors Let’s continue to model the length of the iris petal based on the length of the sepal, controlling for species. But here we’ll keep species as a categorical variable. What happens if we just put the variable in the model? summary(lm(Petal.Length ~ Sepal.Length + Species, data=iris)) ## ## Call: ## lm(formula = Petal.Length ~ Sepal.Length + Species, data = iris) ## ## Residuals: ## Min 1Q Median 3Q Max ## -0.76390 -0.17875 0.00716 0.17461 0.79954 ## ## Coefficients: ## Estimate Std. Error t value Pr(&gt;|t|) ## (Intercept) -1.70234 0.23013 -7.397 1.01e-11 *** ## Sepal.Length 0.63211 0.04527 13.962 &lt; 2e-16 *** ## Speciesversicolor 2.21014 0.07047 31.362 &lt; 2e-16 *** ## Speciesvirginica 3.09000 0.09123 33.870 &lt; 2e-16 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## Residual standard error: 0.2826 on 146 degrees of freedom ## Multiple R-squared: 0.9749, Adjusted R-squared: 0.9744 ## F-statistic: 1890 on 3 and 146 DF, p-value: &lt; 2.2e-16 Examine the coefficient names, Speciesversicolor and Speciesvirginica. R (and most software packages) automatically take a categorical variable and turn it into a series of binary indicator variables. Let’s look at what the software program does in the background. Below is a sample of the iris data. The first column shows the row number, specifically I am only showing 2 sample rows from each species. The second column is the value of the sepal length, the third is the binary indicator for if the iris is from species versicolor, next the binary indicator for if the iris is from species virginica, and lastly the species as a 3 level categorical variable (which is what we’re used to seeing at this point.) Sepal.Length Speciesversicolor Speciesvirginica Species 1 5.1 0 0 setosa 2 4.9 0 0 setosa 51 7 1 0 versicolor 52 6.4 1 0 versicolor 101 6.3 0 1 virginica 102 5.8 0 1 virginica 4.1.1 Factor variable coding Most commonly known as “Dummy coding”. Not an informative term to use. Better used term: Indicator variable Math notation: I(gender == “Female”). A.k.a reference coding For a nominal X with K categories, define K indicator variables. Choose a reference (referent) category: Leave it out Use remaining K-1 in the regression. Often, the largest category is chosen as the reference category. For the iris example, 2 indicator variables are created for versicolor and virginica. Interpreting the regression coefficients are going to be compared to the reference group. In this case, it is species setosa. The mathematical model is now written as follows, where \\(x_{1}\\) is Sepal Length, \\(x_{2}\\) is the indicator for versicolor, and \\(x_{3}\\) the indicator for virginica \\[ Y_{i} \\sim \\beta_{0} + \\beta_{1}x_{i} + \\beta_{2}x_{2i} + \\beta_{3}x_{3i}+ \\epsilon_{i}\\] Let’s look at the regression coefficients and their 95% confidence intervals from the main effects model again. main.eff.model &lt;- lm(Petal.Length ~ Sepal.Length + Species, data=iris) pander(main.eff.model) Fitting linear model: Petal.Length ~ Sepal.Length + Species Estimate Std. Error t value Pr(&gt;|t|) (Intercept) -1.702 0.2301 -7.397 1.005e-11 Sepal.Length 0.6321 0.04527 13.96 1.121e-28 Speciesversicolor 2.21 0.07047 31.36 9.646e-67 Speciesvirginica 3.09 0.09123 33.87 4.918e-71 pander(confint(main.eff.model)) 2.5 % 97.5 % (Intercept) -2.157 -1.248 Sepal.Length 0.5426 0.7216 Speciesversicolor 2.071 2.349 Speciesvirginica 2.91 3.27 In this main effects model, Species only changes the intercept. The effect of species is not multiplied by Sepal length. The interpretations are the following: \\(b_{1}\\): After controlling for species, Petal length significantly increases with the length of the sepal (0.63, 95% CI 0.54-0.72, p&lt;.0001). \\(b_{2}\\): Versicolor has on average 2.2cm longer petal lengths compared to setosa (95% CI 2.1-2.3, p&lt;.0001). \\(b_{3}\\): Virginica has on average 3.1cm longer petal lengths compared to setosa (95% CI 2.9-3.3, p&lt;.0001). 4.1.2 Wald test The Wald test is used for simultaneous tests of \\(Q\\) variables in a model Consider a model with \\(P\\) variables and you want to test if \\(Q\\) additional variables are useful. \\(H_{0}: Q\\) additional variables are useless, i.e., their \\(\\beta\\)’s all = 0 \\(H_{A}: Q\\) additional variables are useful This can be done in R by using the regTermTest() function in the survey package. library(survey) regTermTest(main.eff.model, &quot;Species&quot;) ## Wald test for Species ## in lm(formula = Petal.Length ~ Sepal.Length + Species, data = iris) ## F = 624.9854 on 2 and 146 df: p= &lt; 2.22e-16 4.1.2.0.1 Example 1: Employment status on depression score Consider a model to predict depression using age, employment status and whether or not the person was chronically ill in the past year as covariates. This example uses the cleaned depression data set. depress &lt;- read.delim(&quot;https://norcalbiostat.netlify.com/data/depress_081217.txt&quot;, header=TRUE,sep=&quot;\\t&quot;) full_model &lt;- lm(cesd ~ age + chronill + employ, data=depress) pander(summary(full_model)) Estimate Std. Error t value Pr(&gt;|t|) (Intercept) 11.48 1.502 7.646 3.191e-13 age -0.133 0.03514 -3.785 0.0001873 chronill 2.688 1.024 2.625 0.009121 employHouseperson 6.75 1.797 3.757 0.0002083 employIn School 1.967 5.995 0.328 0.7431 employOther 4.897 4.278 1.145 0.2533 employPT 3.259 1.472 2.214 0.02765 employRetired 3.233 1.886 1.714 0.08756 employUnemp 7.632 2.339 3.263 0.001238 Fitting linear model: cesd ~ age + chronill + employ Observations Residual Std. Error \\(R^2\\) Adjusted \\(R^2\\) 294 8.385 0.1217 0.09704 The results of this model show that age and chronic illness are statistically associated with CESD (each p&lt;.006). However employment status shows mixed results. Some employment statuses are significantly different from the reference group, some are not. So overall, is employment status associated with depression? Recall that employment is a categorical variable, and all the coefficient estimates shown are the effect of being in that income category has on depression compared to being employed full time. For example, the coefficient for PT employment is greater than zero, so they have a higher CESD score compared to someone who is fully employed. But what about employment status overall? Not all employment categories are significantly different from FT status. To test that employment status affects CESD we need to do a global test that all \\(\\beta\\)’s are 0. \\(H_{0}: \\beta_{3} = \\beta_{4} = \\beta_{5} = \\beta_{6} = \\beta_{7} = \\beta_{8} = 0\\) \\(H_{A}\\): At least one \\(\\beta_{j}\\) is not 0. regTermTest(full_model, &quot;employ&quot;) ## Wald test for employ ## in lm(formula = cesd ~ age + chronill + employ, data = depress) ## F = 4.153971 on 6 and 285 df: p= 0.0005092 Confirm that the degrees of freedom are correct. It should equal the # of categories in the variable you are testing, minus 1. Employment has 7 levels, so \\(df=6\\). Or equivalently, the degrees of freedom are the number of \\(beta\\)’s you are testing to be 0. The p-value of this Wald test is significant, thus employment significantly predicts CESD score. load(url(&quot;https://norcalbiostat.netlify.com/data/addhealth_clean.Rdata&quot;)) addhealth$smoke &lt;- ifelse(addhealth$eversmoke_c==&quot;Smoker&quot;, 1, 0) 4.1.2.1 Example 2: Blood Pressure Consider a logistic model on smoking status (0= never smoked, 1=has smoked) using gender, income, and blood pressure class (bp_class) as predictors. \\[ logit(Y) = \\beta_{0} + \\beta_{1}\\mbox{(female)} + \\beta_{2}\\mbox{(income)} + \\beta_{3}\\mbox{(Pre-HTN)} + \\beta_{4}\\mbox{(HTN-I)} + \\beta_{5}\\mbox{(HTN-II)} \\] bp.mod &lt;- glm(smoke ~ female_c + income + bp_class, data=addhealth, family=&#39;binomial&#39;) pander(summary(bp.mod)) Estimate Std. Error z value Pr(&gt;|z|) (Intercept) 1.046 0.1064 9.836 7.881e-23 female_cFemale -0.6182 0.07617 -8.117 4.798e-16 income -3.929e-06 1.411e-06 -2.785 0.005346 bp_classPre-HTN 0.07289 0.08206 0.8882 0.3745 bp_classHTN-I -0.02072 0.1093 -0.1895 0.8497 bp_classHTN-II 0.02736 0.1888 0.1449 0.8848 (Dispersion parameter for binomial family taken to be 1 ) Null deviance: 4853 on 3728 degrees of freedom Residual deviance: 4769 on 3723 degrees of freedom It is unlikely that blood pressure is associated with smoking status, all groups are not statistically significantly different from the reference group (all p-values are large). Let’s test that hypothesis formally using a Wald Test. regTermTest(bp.mod, &quot;bp_class&quot;) ## Wald test for bp_class ## in glm(formula = smoke ~ female_c + income + bp_class, family = &quot;binomial&quot;, ## data = addhealth) ## F = 0.428004 on 3 and 3723 df: p= 0.73294 The Wald Test has a large p-value of 0.73, thus blood pressure classification is not associated with smoking status. This means blood pressure classification should not be included in a model to explain smoking status. "],
["stratification.html", "4.2 Stratification", " 4.2 Stratification Stratified models examine the regression equations for each subgroup of the population and seeing if the relationship between the response and explanatory variables changed for at least one subgroup. Consider the relationship between the length of an iris petal, and the length of it’s sepal. Earlier we found that the iris species modified this relationship. Lets consider a binary indicator variable for species that groups veriscolor and virginica together. iris$setosa &lt;- ifelse(iris$Species==&quot;setosa&quot;, 1, 0) table(iris$setosa, iris$Species) ## ## setosa versicolor virginica ## 0 0 50 50 ## 1 50 0 0 Within the setosa species, there is little to no relationship between sepal and petal length. For the other two species, the relationship looks still significantly positive, but in the combined sample there appears to be a strong positive relationship (blue). ggplot(iris, aes(x=Sepal.Length, y=Petal.Length, col=as.factor(setosa))) + geom_point() + theme_bw() + theme(legend.position=&quot;top&quot;) + scale_color_manual(name=&quot;Species setosa&quot;, values=c(&quot;red&quot;, &quot;darkgreen&quot;)) + geom_smooth(se=FALSE, method=&quot;lm&quot;) + geom_smooth(aes(x=Sepal.Length, y=Petal.Length), col=&quot;blue&quot;, se=FALSE, method=&#39;lm&#39;) The mathematical model describing the relationship between Petal length (\\(Y\\)), and Sepal length (\\(X\\)), for species setosa (\\(s\\)) versus not-setosa (\\(n\\)), is written as follows: \\[ Y_{is} \\sim \\beta_{0s} + \\beta_{1s}*x_{i} + \\epsilon_{is} \\qquad \\epsilon_{is} \\sim \\mathcal{N}(0,\\sigma^{2}_{s})\\] \\[ Y_{in} \\sim \\beta_{0n} + \\beta_{1n}*x_{i} + \\epsilon_{in} \\qquad \\epsilon_{in} \\sim \\mathcal{N}(0,\\sigma^{2}_{n}) \\] In each model, the intercept, slope, and variance of the residuals can all be different. This is the unique and powerful feature of stratified models. The downside is that each model is only fit on the amount of data in that particular subset. Furthermore, each model has 3 parameters that need to be estimated: \\(\\beta_{0}, \\beta_{1}\\), and \\(\\sigma^{2}\\), for a total of 6 for the two models. The more parameters that need to be estimated, the more data we need. "],
["moderation.html", "4.3 Moderation", " 4.3 Moderation Moderation occurs when the relationship between two variables depends on a third variable. The third variable is referred to as the moderating variable or simply the moderator. The moderator affects the direction and/or strength of the relationship between the explanatory (\\(x\\)) and response (\\(y\\)) variable. This tends to be an important When testing a potential moderator, we are asking the question whether there is an association between two constructs, but separately for different subgroups within the sample. This is also called a stratified model, or a subgroup analysis. Here are 3 scenarios demonstrating how a third variable can modify the relationship between the original two variables. Scenario 1 - Significant relationship at bivariate level (saying expect the effect to exist in the entire population) then when test for moderation the third variable is a moderator if the strength (i.e., p-value is Non-Significant) of the relationship changes. Could just change strength for one level of third variable, not necessarily all levels of the third variable. Scenario 2 - Non-significant relationship at bivariate level (saying do not expect the effect to exist in the entire population) then when test for moderation the third variable is a moderator if the relationship becomes significant (saying expect to see it in at least one of the sub-groups or levels of third variable, but not in entire population because was not significant before tested for moderation). Could just become significant in one level of the third variable, not necessarily all levels of the third variable. Scenario 3 - Significant relationship at bivariate level (saying expect the effect to exist in the entire population) then when test for moderation the third variable is a moderator if the direction (i.e., means change order/direction) of the relationship changes. Could just change direction for one level of third variable, not necessarily all levels of the third variable. 4.3.1 Example "],
["interactions.html", "4.4 Interactions", " 4.4 Interactions If we care about how species changes the relationship between petal and sepal length, we can fit a model with an interaction between sepal length (\\(x_{1}\\)) and species. For this first example let \\(x_{2}\\) be an indicator for when species == setosa . Note that both main effects of sepal length, and setosa species are also included in the model. Interactions are mathematically represented as a multiplication between the two variables that are interacting. \\[ Y_{i} \\sim \\beta_{0} + \\beta_{1}x_{i} + \\beta_{2}x_{2i} + \\beta_{3}x_{1i}x_{2i}\\] Ifwe evaluate this model for both levels of \\(x_{2}\\), the resulting models are the same as the stratified models. When \\(x_{2} = 0\\), the record is on an iris not from the setosa species. \\[ Y_{i} \\sim \\beta_{0} + \\beta_{1}x_{i} + \\beta_{2}(0) + \\beta_{3}x_{1i}(0)\\] which simplifies to \\[ Y_{i} \\sim \\beta_{0} + \\beta_{1}x_{i}\\] When \\(x_{2} = 1\\), the record is on an iris of the setosa species. \\[ Y_{i} \\sim \\beta_{0} + \\beta_{1}x_{i} + \\beta_{2}(1) + \\beta_{3}x_{1i}(1)\\] which simplifies to \\[ Y_{i} \\sim (\\beta_{0} + \\beta_{2}) + (\\beta_{1} + \\beta_{3})x_{i}\\] Each subgroup model has a different intercept and slope, but we had to estimate 4 parameters in the interaction model, and 6 for the fully stratified model. Interactions are fit in R by simply multiplying * the two variables together in the model statement. summary(lm(Petal.Length ~ Sepal.Length + setosa + Sepal.Length*setosa, data=iris)) ## ## Call: ## lm(formula = Petal.Length ~ Sepal.Length + setosa + Sepal.Length * ## setosa, data = iris) ## ## Residuals: ## Min 1Q Median 3Q Max ## -0.96754 -0.19948 -0.01386 0.22597 1.05479 ## ## Coefficients: ## Estimate Std. Error t value Pr(&gt;|t|) ## (Intercept) -1.55571 0.37509 -4.148 5.68e-05 *** ## Sepal.Length 1.03189 0.05957 17.322 &lt; 2e-16 *** ## setosa 2.35877 0.88266 2.672 0.00839 ** ## Sepal.Length:setosa -0.90026 0.17000 -5.296 4.28e-07 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## Residual standard error: 0.3929 on 146 degrees of freedom ## Multiple R-squared: 0.9515, Adjusted R-squared: 0.9505 ## F-statistic: 954.1 on 3 and 146 DF, p-value: &lt; 2.2e-16 The coefficient \\(b_{3}\\) for the interaction term is significant, confirming that species changes the relationship between sepal length and petal length. 4.4.1 Example summary(lm(Petal.Length ~ Sepal.Length + setosa + Sepal.Length*setosa, data=iris)) ## ## Call: ## lm(formula = Petal.Length ~ Sepal.Length + setosa + Sepal.Length * ## setosa, data = iris) ## ## Residuals: ## Min 1Q Median 3Q Max ## -0.96754 -0.19948 -0.01386 0.22597 1.05479 ## ## Coefficients: ## Estimate Std. Error t value Pr(&gt;|t|) ## (Intercept) -1.55571 0.37509 -4.148 5.68e-05 *** ## Sepal.Length 1.03189 0.05957 17.322 &lt; 2e-16 *** ## setosa 2.35877 0.88266 2.672 0.00839 ** ## Sepal.Length:setosa -0.90026 0.17000 -5.296 4.28e-07 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## Residual standard error: 0.3929 on 146 degrees of freedom ## Multiple R-squared: 0.9515, Adjusted R-squared: 0.9505 ## F-statistic: 954.1 on 3 and 146 DF, p-value: &lt; 2.2e-16 If \\(x_{2}=0\\), then the effect of \\(x_{1}\\) on \\(Y\\) simplifies to: \\(\\beta_{1}\\) \\(b_{1}\\) The effect of sepal length on petal length for non-setosa species of iris (setosa=0) For non-setosa species, the petal length increases 1.03cm for every additional cm of sepal length. If \\(x_{2}=1\\), then the effect of \\(x_{1}\\) on \\(Y\\) model simplifies to: \\(\\beta_{1} + \\beta_{3}\\) For setosa species, the petal length increases by 1.03-0.9=0.13 cm for every additional cm of sepal length. The main effects (\\(b_{1}\\), \\(b_{2}\\)) cannot be interpreted by themselves when there is an interaction in the model. Let’s up the game now and look at the full interaction model with a categorical version of species. Recall \\(x_{1}\\) is Sepal Length, \\(x_{2}\\) is the indicator for versicolor, and \\(x_{3}\\) the indicator for virginica . \\[ Y_{i} \\sim \\beta_{0} + \\beta_{1}x_{i} + \\beta_{2}x_{2i} + \\beta_{3}x_{3i} + \\beta_{4}x_{1i}x_{2i} + \\beta_{5}x_{1i}x_{3i}+\\epsilon_{i}\\] summary(lm(Petal.Length ~ Sepal.Length + Species + Sepal.Length*Species, data=iris)) ## ## Call: ## lm(formula = Petal.Length ~ Sepal.Length + Species + Sepal.Length * ## Species, data = iris) ## ## Residuals: ## Min 1Q Median 3Q Max ## -0.68611 -0.13442 -0.00856 0.15966 0.79607 ## ## Coefficients: ## Estimate Std. Error t value Pr(&gt;|t|) ## (Intercept) 0.8031 0.5310 1.512 0.133 ## Sepal.Length 0.1316 0.1058 1.244 0.216 ## Speciesversicolor -0.6179 0.6837 -0.904 0.368 ## Speciesvirginica -0.1926 0.6578 -0.293 0.770 ## Sepal.Length:Speciesversicolor 0.5548 0.1281 4.330 2.78e-05 *** ## Sepal.Length:Speciesvirginica 0.6184 0.1210 5.111 1.00e-06 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## Residual standard error: 0.2611 on 144 degrees of freedom ## Multiple R-squared: 0.9789, Adjusted R-squared: 0.9781 ## F-statistic: 1333 on 5 and 144 DF, p-value: &lt; 2.2e-16 The slope of the relationship between sepal length and petal length is calculated as follows, for each species: setosa \\((x_{2}=0, x_{3}=0): b_{1}=0.13\\) versicolor \\((x_{2}=1, x_{3}=0): b_{1} + b_{2} + b_{4} = 0.13+0.55 = 0.68\\) virginica \\((x_{2}=0, x_{3}=1): b_{1} + b_{3} + b_{5} = 0.13+0.62 = 0.75\\) Compare this to the estimates gained from the stratified model: coef(lm(Petal.Length ~ Sepal.Length, data=subset(iris, Species==&quot;setosa&quot;))) ## (Intercept) Sepal.Length ## 0.8030518 0.1316317 coef(lm(Petal.Length ~ Sepal.Length, data=subset(iris, Species==&quot;versicolor&quot;))) ## (Intercept) Sepal.Length ## 0.1851155 0.6864698 coef(lm(Petal.Length ~ Sepal.Length, data=subset(iris, Species==&quot;virginica&quot;))) ## (Intercept) Sepal.Length ## 0.6104680 0.7500808 They’re the same! Proof that an interaction is equivalent to stratification. 4.4.2 Example What if we now wanted to include other predictors in the model? How does sepal length relate to petal length after controlling for petal width? We add the variable for petal width into the model summary(lm(Petal.Length ~ Sepal.Length + setosa + Sepal.Length*setosa + Petal.Width, data=iris)) ## ## Call: ## lm(formula = Petal.Length ~ Sepal.Length + setosa + Sepal.Length * ## setosa + Petal.Width, data = iris) ## ## Residuals: ## Min 1Q Median 3Q Max ## -0.83519 -0.18278 -0.01812 0.17004 1.06968 ## ## Coefficients: ## Estimate Std. Error t value Pr(&gt;|t|) ## (Intercept) -0.86850 0.27028 -3.213 0.00162 ** ## Sepal.Length 0.66181 0.05179 12.779 &lt; 2e-16 *** ## setosa 1.83713 0.62355 2.946 0.00375 ** ## Petal.Width 0.97269 0.07970 12.204 &lt; 2e-16 *** ## Sepal.Length:setosa -0.61106 0.12213 -5.003 1.61e-06 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## Residual standard error: 0.2769 on 145 degrees of freedom ## Multiple R-squared: 0.9761, Adjusted R-squared: 0.9754 ## F-statistic: 1478 on 4 and 145 DF, p-value: &lt; 2.2e-16 So far, petal width, and the combination of species and sepal length are both significantly associated with petal length. Note of caution: Stratification implies that the stratifying variable interacts with all other variables. So if we were to go back to the stratified model where we fit the model of petal length on sepal length AND petal width, stratified by species, we would be implying that species interacts with both sepal length and petal width. E.g. the following stratified model \\(Y = A + B + C + D + C*D\\), when D=1 \\(Y = A + B + C + D + C*D\\), when D=0 is the same as the following interaction model: \\(Y = A + B + C + D + A*D + B*D + C*D\\) "],
["variable-selection-process.html", "4.5 Variable Selection Process", " 4.5 Variable Selection Process We want to choose a set of independent variables that both will yield a good prediction using as few variables as possible. In many situations where regression is used, the investigator has strong justification for including certain variables in the model. previous studies accepted theory The investigator may have prior justification for using certain variables but may be open to suggestions for the remaining variables. The set of independent variables can be broken down into logical subsets The usual demographics are entered first (age, gender, ethnicity) A set of variables that other studies have shown to affect the dependent variable A third set of variables that could be associated but the relationship has not yet been examined. Partially model-driven regression analysis and partially an exploratory analysis. Automated versions of variable selection processes should not be used blindly. 4.5.1 Confounding One primary purpose of a multivariable model is to assess the relationship between a particular explanatory variable \\(x\\) and your response variable \\(y\\), after controlling for other factors. As we just discussed, those other factors (characteristics/variables) could also be explaining part of the variability seen in \\(y\\). If the relationship between \\(x_{1}\\) and \\(y\\) is bivariately significant, but then no longer significant once \\(x_{2}\\) has been added to the model, then \\(x_{2}\\) is said to explain, or confound, the relationship between \\(x_{1}\\) and \\(y\\). 4.5.2 Automated selection procedures Forward selection: X variables added one at a time until optimal model reached Backward elimination: X variables removed one at a time until optimal model reached Stepwise selection: Combination of forward and backward. “… perhaps the most serious source of error lies in letting statistical procedures make decisions for you.” “Don’t be too quick to turn on the computer. Bypassing the brain to compute by reflex is a sure recipe for disaster.” Good and Hardin, Common Errors in Statistics (and How to Avoid Them), p. 3, p. 152 Take home message: Don’t use these. Stopping criteria and algorithm can be different for different software programs. Can reject perfectly plausible models from later consideration Hides relationships between variables (X3 is added and now X1 is no longer significant. X1 vs X3 should be looked at) 4.5.3 Best Subsets (PMA5 Section 8.7) Select one X with highest simple \\(r\\) with Y Select two X’s with highest multiple \\(r\\) with Y Select three X’s with highest multiple \\(r\\) with Y etc. Compute adjusted R2, AIC or BIC each time. Compare and choose among the “best subsets” of various sizes. Ways to conduct best subsets regression in R: https://rstudio-pubs-static.s3.amazonaws.com/2897_9220b21cfc0c43a396ff9abf122bb351.html "],
["comparing-between-models.html", "4.6 Comparing between models", " 4.6 Comparing between models When working with multiple models, how do you choose between models? There are several measures we can use to compare between competing models. Multiple \\(R^{2}\\) If the model explains a large amount of variation in the outcome that’s good right? So we could consider using \\(R^{2}\\) as a selection criteria and trying to find the model that maximizes this value. The residual sum of squares (RSS in the book or SSE) can be written as \\(\\sum(Y-\\hat{Y})^{2}(1-R^{2})\\). Therefore minimizing the RSS is equivalent to maximizing the multiple correlation coefficient. Problem: The multiple \\(R^{2}\\) always increases as predictors are added to the model. - Ex. 1: N = 100, P = 1, E(\\(R^{2}\\)) = 0.01 - Ex. 2: N = 21, P = 10, E(\\(R^{2}\\)) = 0.5 Problem: \\(R^{2} = 1-\\frac{Model SS}{Total SS}\\) is biased: If population \\(R^{2}\\) is really zero, then E(\\(R^{2}\\)) = P/(N-1). Adjusted \\(R^{2}\\) To alleviate bias use Mean squares instead of SS. \\(R^{2} = 1-\\frac{Model MS}{Total MS}\\) equivalently, \\(R^{2}_{adj} = R^{2} - \\frac{p(1-R^{2})}{n-p-1}\\) Now Adjusted \\(R^{2}\\) is approximately unbiased and won’t inflate as \\(p\\) increases. Mallows \\(C_{p}\\) \\[ C_{p} = (N-P-1)\\left(\\frac{RMSE}{\\hat{\\sigma}^{2}} -1 \\right) + (P+1) \\] Smaller is better When all variables are chosen, \\(P+1\\) is at it’s maximum but the other part of \\(C_{p}\\) is zero since \\(RMSE\\)==\\(\\hat{\\sigma}^{2}\\) Akaike Information Criterion (AIC) A penalty is applied to the deviance that increases as the number of parameters \\(p\\) increase. Tries to find a parsimonious model that is closer to the “truth”. Uses an information function, e.g., the likelihood function \\((LL)\\). \\[ AIC = -2LL + 2p\\] Smaller is better Can also be written as a function of the residual sum of squares (RSS) (in book) Bayesian Information Criterion (BIC) Similar to AIC. Tries to find a parsimonious model that is more likely to be the “truth”. The smaller BIC, the better. \\[ BIC = -2LL + ln(N)*(P+1)\\] AIC vs BIC Both are “penalized likelihood” functions Each = -2log likelihood + penalty AIC: penalty = 2, BIC: penalty = ln(N) For any N &gt; 7, ln(N) &gt; 2 Thus, BIC penalizes larger models more heavily. They often agree. When they disagree, AIC chooses a larger model than BIC. "],
["what-to-watch-out-for-1.html", "4.7 What to watch out for", " 4.7 What to watch out for Use previous research as a guide Variables not included can bias the results Significance levels are only a guide Perform model diagnostics after selection to check model fit. Use common sense: A sub-optimal subset may make more sense than optimal one "],
["glm.html", "Chapter 5 Generalized Linear Models", " Chapter 5 Generalized Linear Models One of the primary assumptions with linear regression, is that the error terms have a specific distribution. Namely: \\[ \\epsilon_{i} \\sim \\mathcal{N}(0, \\sigma^{2}) \\qquad i=1, \\ldots, n, \\quad \\mbox{and } \\epsilon_{i} \\perp \\epsilon_{j}, i \\neq j \\] When your outcome variable \\(y\\) is non-continuous/non-normal, the above assumption fails dramatically. Generalized Linear Models (GLM) allows for different data type outcomes by allowing the linear portion of the model (\\(\\mathbf{X}\\beta\\)) to be related to the outcome variable \\(y\\) using a link function, that allows the magnitude of the variance of the errors (\\(\\sigma\\)) to be related to the predicted values themselves. There are three overarching types of non-continuous outcomes that can be modeled with GLM’s. Binary data: Logistic or Probit regression Multinomial/categorical data: Multinomial or Ordinal Logistic regression. Count data: Poisson regression At this time these notes goes into depth for Logistic regression only, due to its commonplace in data analysis tools. "],
["fitting-glms-in-r.html", "5.1 Fitting GLMs in R", " 5.1 Fitting GLMs in R Generalized linear regression models can be fit in R using the glm() function. This function can fit an entire family of distributions and can be thought of as \\(E(Y|X) = C(X)\\) where \\(C\\) is the link function that relates \\(Y\\) to \\(X\\). Linear regression: C = Identity function (no change) Logistic regression: C = logit function Poisson regression: C = log function The general syntax is similar to lm(), with the additional required family= argument. See ?family for a list of options. glm(y ~ x1 + x2 + x3, data=DATA, family=&quot;binomial&quot;) "],
["binary-data.html", "5.2 Binary Data", " 5.2 Binary Data Goals: Assess the impact selected covariates have on the probability of an outcome occurring. Predict the likelihood / chance / probability of an event occurring given a certain covariate pattern. Binary data can be fit using a Logistic Model or a Probit Model. Consider an outcome variable \\(Y\\) with two levels: Y = 1 if event, = 0 if no event. Let \\(p_{i} = P(y_{i}=1)\\). The logistic model relates the probability of an event based on a linear combination of X’s. \\[ log\\left( \\frac{p_{i}}{1-p_{i}} \\right) = \\beta_{0} + \\beta_{1}x_{1i} + \\beta_{2}x_{2i} + \\ldots + \\beta_{p}x_{pi} \\] Since the odds are defined as the probability an event occurs divided by the probability it does not occur: \\((p/(1-p))\\), the function \\(log\\left(\\frac{p_{i}}{1-p_{i}}\\right)\\) is also known as the log odds, or more commonly called the logit. This is the link function for the logistic regression model. This in essence takes a binary outcome 0/1 variable, turns it into a continuous probability (which only has a range from 0 to 1) Then the logit(p) has a continuous distribution ranging from \\(-\\infty\\) to \\(\\infty\\), which is the same form as a Multiple Linear Regression (continuous outcome modeled on a set of covariates) Back solving the logistic model for \\(p_{i} = e^{\\beta X} / (1+e^{\\beta X})\\) gives us the probability of an event. \\[ p_{i} = \\frac{e^{\\beta_{0} + \\beta_{1}x_{1i} + \\beta_{2}x_{2i} + \\ldots + \\beta_{p}x_{pi}}} {1 + e^{\\beta_{0} + \\beta_{1}x_{1i} + \\beta_{2}x_{2i} + \\ldots + \\beta_{p}x_{pi}}} \\] The probit function uses the inverse CDF for the normal distribution as the link function. 5.2.1 Example: The effect of gender on Depression Is gender associated with depression? Read in the depression data and recode sex to be an indicator of being male. depress &lt;- read.delim(&quot;https://norcalbiostat.netlify.com/data/depress_081217.txt&quot;) names(depress) &lt;- tolower(names(depress)) # make all variable names lower case. Binary outcome variable: Symptoms of Depression (cases) Binary predictor variable: Gender (sex) as an indicator of being female The outcome \\(y\\) is a 0/1 Bernoulli random variable. The sum of a vector of Bernoulli’s (\\(\\sum_{i=1}^{n}y_{i}\\)) has a Binomial distribution. When we specify that family = &quot;binomial&quot; the glm() function auto-assigns “logit” link function. dep_sex_model &lt;- glm(cases ~ sex, data=depress, family=&quot;binomial&quot;) summary(dep_sex_model) ## ## Call: ## glm(formula = cases ~ sex, family = &quot;binomial&quot;, data = depress) ## ## Deviance Residuals: ## Min 1Q Median 3Q Max ## -0.7023 -0.7023 -0.4345 -0.4345 2.1941 ## ## Coefficients: ## Estimate Std. Error z value Pr(&gt;|z|) ## (Intercept) -2.3125 0.3315 -6.976 3.04e-12 *** ## sex 1.0386 0.3767 2.757 0.00583 ** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## (Dispersion parameter for binomial family taken to be 1) ## ## Null deviance: 268.12 on 293 degrees of freedom ## Residual deviance: 259.40 on 292 degrees of freedom ## AIC: 263.4 ## ## Number of Fisher Scoring iterations: 5 We exponentiate the coefficients to back transform the \\(\\beta\\) estimates into Odds Ratios exp(coef(dep_sex_model)) ## (Intercept) sex ## 0.0990099 2.8251748 Females have 2.8 times the odds of showing signs of depression compared to males. Confidence Intervals The OR is not a linear function of the \\(x&#39;s\\), but \\(\\beta\\) is. This means that a CI for the OR is created by calculating a CI for \\(\\beta\\), and then exponentiating the endpoints. A 95% CI for the OR can be calculated as: \\[e^{\\hat{\\beta} \\pm 1.96 SE_{\\beta}} \\] exp(confint(dep_sex_model)) ## 2.5 % 97.5 % ## (Intercept) 0.04843014 0.1801265 ## sex 1.39911056 6.2142384 5.2.2 Multiple Logistic Regression Just like multiple linear regression, additional predictors are simply included in the model using a + symbol. mvmodel &lt;- glm(cases ~ age + income + sex, data=depress, family=&quot;binomial&quot;) summary(mvmodel) ## ## Call: ## glm(formula = cases ~ age + income + sex, family = &quot;binomial&quot;, ## data = depress) ## ## Deviance Residuals: ## Min 1Q Median 3Q Max ## -1.0249 -0.6524 -0.5050 -0.3179 2.5305 ## ## Coefficients: ## Estimate Std. Error z value Pr(&gt;|z|) ## (Intercept) -0.67646 0.57881 -1.169 0.24253 ## age -0.02096 0.00904 -2.318 0.02043 * ## income -0.03656 0.01409 -2.595 0.00946 ** ## sex 0.92945 0.38582 2.409 0.01600 * ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## (Dispersion parameter for binomial family taken to be 1) ## ## Null deviance: 268.12 on 293 degrees of freedom ## Residual deviance: 247.54 on 290 degrees of freedom ## AIC: 255.54 ## ## Number of Fisher Scoring iterations: 5 The sign of the \\(\\beta\\) coefficients can be interpreted in the same manner as with linear regression. The odds of being depressed are less if the respondent has a higher income and is older, and higher if the respondent is female. 5.2.3 Interpretation The OR provides a directly understandable statistic for the relationship between \\(y\\) and a specific \\(x\\) given all other \\(x\\)’s in the model are fixed. For a continuous variable X with slope coefficient \\(\\beta\\), the quantity \\(e^{b}\\) is interpreted as the ratio of the odds for a person with value (X+1) relative to the odds for a person with value X. \\(exp(kb)\\) is the incremental odds ratio corresponding to an increase of \\(k\\) units in the variable X, assuming that the values of all other X variables remain unchanged. Where does \\(OR = e^{\\beta}\\) come from? The full model is: \\[log(odds) = -0.676 - 0.02096*age - .03656*income + 0.92945*gender\\] We want to calculate the Odds Ratio of depression for women compared to men. \\[ OR = \\frac{Odds (Y=1|F)}{Odds (Y=1|M)} \\] Write out the equations for men and women separately. \\[ = \\frac{e^{-0.676 - 0.02096*age - .03656*income + 0.92945(1)}} {e^{-0.676 - 0.02096*age - .03656*income + 0.92945(0)}}\\] Applying rules of exponents to simplify. \\[ = \\frac{e^{-0.676}e^{- 0.02096*age}e^{- .03656*income}e^{0.92945(1)}} {e^{-0.676}e^{- 0.02096*age}e^{- .03656*income}e^{0.92945(0)}}\\] \\[ = \\frac{e^{0.92945(1)}} {e^{0.92945(0)}}\\] \\[ = e^{0.92945} \\] exp(.92945) ## [1] 2.533116 exp(coef(mvmodel)[4]) ## sex ## 2.533112 The odds of a female being depressed are 2.53 times greater than the odds for Males after adjusting for the linear effects of age and income (p=.016). 5.2.3.1 Effect of a k unit change Sometimes a 1 unit change in a continuous variable is not meaningful. exp(coef(mvmodel)) ## (Intercept) age income sex ## 0.5084157 0.9792605 0.9640969 2.5331122 exp(confint(mvmodel)) ## 2.5 % 97.5 % ## (Intercept) 0.1585110 1.5491849 ## age 0.9615593 0.9964037 ## income 0.9357319 0.9891872 ## sex 1.2293435 5.6586150 The Adjusted odds ratio (AOR) for increase of 1 year of age is 0.98 (95%CI .96, 1.0) How about a 10 year increase in age? \\(e^{10*\\beta_{age}} = e^{-.21} = .81\\) exp(10*coef(mvmodel)[2]) ## age ## 0.8109285 with a confidence interval of round(exp(10*confint(mvmodel)[2,]),3) ## 2.5 % 97.5 % ## 0.676 0.965 Controlling for gender and income, an individual has 0.81 (95% CI 0.68, 0.97) times the odds of being depressed compared to someone who is 10 years younger than them. 5.2.3.1.1 Example: The relationship between income, employment status and depression. This example follows PMA5 Ch 12.7 Here I create the binary indicators of lowincome (annual income &lt;$10k/year) and underemployed (part time or unemployed). depress$lowincome &lt;- ifelse(depress$income &lt; 10, 1, 0) table(depress$lowincome, depress$income, useNA=&quot;always&quot;) ## ## 2 4 5 6 7 8 9 11 12 13 15 16 18 19 20 23 24 25 26 27 28 31 ## 0 0 0 0 0 0 0 0 17 2 18 24 1 1 25 3 25 2 1 1 1 19 1 ## 1 7 8 10 12 18 14 22 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 ## &lt;NA&gt; 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 ## ## 32 35 36 37 42 45 55 65 &lt;NA&gt; ## 0 1 24 1 1 1 15 9 10 0 ## 1 0 0 0 0 0 0 0 0 0 ## &lt;NA&gt; 0 0 0 0 0 0 0 0 0 depress$underemployed &lt;- ifelse(depress$employ %in% c(&quot;PT&quot;, &quot;Unemp&quot;), 1, 0 ) table(depress$underemployed, depress$employ, useNA=&quot;always&quot;) ## ## FT Houseperson In School Other PT Retired Unemp &lt;NA&gt; ## 0 167 27 2 4 0 38 0 0 ## 1 0 0 0 0 42 0 14 0 ## &lt;NA&gt; 0 0 0 0 0 0 0 0 The Main Effects model assumes that the effect of income on depression is independent of employment status, and the effect of employment status on depression is independent of income. me_model &lt;- glm(cases ~ lowincome + underemployed, data=depress, family=&quot;binomial&quot;) summary(me_model) ## ## Call: ## glm(formula = cases ~ lowincome + underemployed, family = &quot;binomial&quot;, ## data = depress) ## ## Deviance Residuals: ## Min 1Q Median 3Q Max ## -0.9085 -0.5843 -0.5279 -0.5279 2.0197 ## ## Coefficients: ## Estimate Std. Error z value Pr(&gt;|z|) ## (Intercept) -1.9003 0.2221 -8.556 &lt; 2e-16 *** ## lowincome 0.2192 0.3353 0.654 0.51322 ## underemployed 1.0094 0.3470 2.909 0.00363 ** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## (Dispersion parameter for binomial family taken to be 1) ## ## Null deviance: 268.12 on 293 degrees of freedom ## Residual deviance: 259.93 on 291 degrees of freedom ## AIC: 265.93 ## ## Number of Fisher Scoring iterations: 4 To formally test whether an interaction term is necessary, we add the interaction term into the model and assess whether the coefficient for the interaction term is significantly different from zero. me_intx_model &lt;- glm(cases ~ lowincome + underemployed + lowincome*underemployed, data=depress, family=&quot;binomial&quot;) summary(me_intx_model) ## ## Call: ## glm(formula = cases ~ lowincome + underemployed + lowincome * ## underemployed, family = &quot;binomial&quot;, data = depress) ## ## Deviance Residuals: ## Min 1Q Median 3Q Max ## -1.3537 -0.5790 -0.5790 -0.4717 2.1219 ## ## Coefficients: ## Estimate Std. Error z value Pr(&gt;|z|) ## (Intercept) -1.7011 0.2175 -7.822 5.21e-15 *** ## lowincome -0.4390 0.4324 -1.015 0.31005 ## underemployed 0.2840 0.4501 0.631 0.52802 ## lowincome:underemployed 2.2615 0.7874 2.872 0.00408 ** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## (Dispersion parameter for binomial family taken to be 1) ## ## Null deviance: 268.12 on 293 degrees of freedom ## Residual deviance: 251.17 on 290 degrees of freedom ## AIC: 259.17 ## ## Number of Fisher Scoring iterations: 4 5.2.4 Goodness of Fit Tests to see if there is sufficient reason to believe that the logistic model does not fit (\\(H_{a}\\)), versus it does fit (\\(H_{0}\\)) This means that a small p-value indicates that the model does not fit the data. We’ll look specifically at the Hosmer-Lemeshow (HL) Goodness of fit (GoF) test 5.2.4.1 HL GoF Compute the probability (\\(p_{i}\\)) of event (risk) for each observation. Sort data by this \\(p\\). Divide into \\(G\\) equal sized groups in ascending order (G=10 is common, i.e. split into deciles) Then for each group we calculate \\(O_{1g}\\): the observed number of events \\(E_{1g}\\): the expected number of events as the \\(\\sum_{i} p_{ig}\\) \\(O_{0g}\\): the observed number of non-events \\(E_{0g}\\): the expected number of events as the \\(1-\\sum_{i} p_{ig}\\) Then the HL test statistic (\\(H\\)) has a \\(\\chi^{2}\\) distribution and is is calculated as: \\[ H = \\sum_{g=1}^{G}\\left({\\frac {(O_{1g}-E_{1g})^{2}}{E_{1g}}}+{\\frac {(O_{0g}-E_{0g})^{2}}{E_{0g}}}\\right) \\sim \\chi^{2}_{G-2} \\] 5.2.4.2 HL GoF in R MKmisc::HLgof.test(fit = fitted(me_intx_model), obs = me_intx_model$y) ## $C ## ## Hosmer-Lemeshow C statistic ## ## data: fitted(me_intx_model) and me_intx_model$y ## X-squared = 5.614e-17, df = 1, p-value = 1 ## ## ## $H ## ## Hosmer-Lemeshow H statistic ## ## data: fitted(me_intx_model) and me_intx_model$y ## X-squared = 5.614e-17, df = 8, p-value = 1 A very low test statistic and a very high p-value indicate that this model fits the data well. 5.2.5 Classification Sometimes Odds Ratios can be difficult to interpret or understand. Sometimes you just want to report the probability of the event occurring. Or sometimes you want to predict whether or not a new individual is going to have the event. For all of these, we need to calculate \\(p_{i} = P(y_{i}=1)\\), the probability of the event. For the main effects model of depression on age, income and gender the predicted probability of depression is: \\[ P(depressed) = \\frac{e^{-0.676 - 0.02096*age - .03656*income + 0.92945*gender}} {1 + e^{-0.676 - 0.02096*age - .03656*income + 0.92945*gender}} \\] Let’s compare the probability of being depressed for males and females separately, while holding age and income constant at their average value. depress %&gt;% summarize(age=mean(age), income=mean(income)) ## age income ## 1 44.41497 20.57483 Plug the coefficient estimates and the values of the variables into the equation and calculate. \\[ P(depressed|Female) = \\frac{e^{-0.676 - 0.02096(44.4) - .03656(20.6) + 0.92945(1)}} {1 + e^{-0.676 - 0.02096(44.4) - .03656(20.6) + 0.92945(1)}} \\] XB.f &lt;- -0.676 - 0.02096*(44.4) - .03656*(20.6) + 0.92945 exp(XB.f) / (1+exp(XB.f)) ## [1] 0.1930504 \\[ P(depressed|Male) = \\frac{e^{-0.676 - 0.02096(44.4) - .03656(20.6) + 0.92945(0)}} {1 + e^{-0.676 - 0.02096(44.4) - .03656(20.6) + 0.92945(0)}} \\] XB.m &lt;- -0.676 - 0.02096*(44.4) - .03656*(20.6) exp(XB.m) / (1+exp(XB.m)) ## [1] 0.08629312 The probability for a 44.4 year old female who makes $20.6k annual income has a 0.19 probability of being depressed. The probability of depression for a male of equal age and income is 0.86. 5.2.6 Calculating predictions So what if you want to get the model predicted probability of the event for all individuals in the data set? There’s no way I’m doing that calculation for every person in the data set. Using the main effects model from above, stored in the object mvmodel, we can call the predict() command to generate a vector of predictions for each row used in the model. Any row with missing data on any variable used in the model will NOT get a predicted value. The predict() function can calculate predictions for any GLM. The model object mvmodel stores the information that it was a logistic regression. model.pred.prob &lt;- predict(mvmodel, type=&#39;response&#39;) head(model.pred.prob) ## 1 2 3 4 5 6 ## 0.21108906 0.08014012 0.15266203 0.24527840 0.15208679 0.17056409 5.2.6.1 Distribution of Predictions How well does our model do to predict depression? plot.mpp &lt;- data.frame(prediction = model.pred.prob, truth = factor(mvmodel$y, labels=c(&quot;Not Depressed&quot;, &quot;Depressed&quot;))) ggplot(plot.mpp, aes(x=truth, y=prediction, fill=truth)) + geom_jitter(width=.2) + geom_violin(alpha=.4) + theme_bw() What things can you infer from this plot? Where should we put the cutoff value? At what probability should we classify a record as “depressed”? 5.2.7 Model Performance Say we decide that a value of 0.15 is our optimal cutoff value. We can use this probability to classify each row into groups. The assigned class values must match the data type and levels of the true value. It also has to be in the same order, so the 0 group needs to come first. Then we calculate a [Confusion Matrix] using the similarly named function from the caret package. At it’s core, this is a 2x2 table containing counts of each combination of predicted value and true value. library(caret) plot.mpp$pred.class &lt;- ifelse(plot.mpp$prediction &lt;0.15, 0,1) plot.mpp$pred.class &lt;- factor(plot.mpp$pred.class, labels=c(&quot;Not Depressed&quot;, &quot;Depressed&quot;)) confusionMatrix(plot.mpp$pred.class, plot.mpp$truth, positive=&quot;Depressed&quot;) ## Confusion Matrix and Statistics ## ## Reference ## Prediction Not Depressed Depressed ## Not Depressed 123 10 ## Depressed 121 40 ## ## Accuracy : 0.5544 ## 95% CI : (0.4956, 0.6121) ## No Information Rate : 0.8299 ## P-Value [Acc &gt; NIR] : 1 ## ## Kappa : 0.1615 ## Mcnemar&#39;s Test P-Value : &lt;2e-16 ## ## Sensitivity : 0.8000 ## Specificity : 0.5041 ## Pos Pred Value : 0.2484 ## Neg Pred Value : 0.9248 ## Prevalence : 0.1701 ## Detection Rate : 0.1361 ## Detection Prevalence : 0.5476 ## Balanced Accuracy : 0.6520 ## ## &#39;Positive&#39; Class : Depressed ## 123 people were correctly predicted to not be depressed (True Negative, \\(n_{11}\\)) 121 people were incorrectly predicted to be depressed (False Positive, \\(n_{21}\\)) 10 people were incorrectly predicted to not be depressed (False Negative, \\(n_{12}\\)) 40 people were correctly predicted to be depressed (True Positive, \\(n_{22}\\)) Other terminology: Sensitivity/Recall/True positive rate: P(condition positive|predicted positive) = 40/(10+40) = .8 Specificity/true negative rate: P(condition negative|predicted negative) = 123/(123+121) = .504 Precision/positive predicted value: P(true positive | predicted positive) = 40/(121+40) = .2484 Accuracy: (TP + TN)/ Total: (40 + 123)/(40+123+121+10) = .5544 Balanced Accuracy: \\([(n_{11}/n_{.1}) + (n_{22}/n_{.2})]/2\\) - This is to adjust for class size imbalances (like in this example) F1 score: the harmonic mean of precision and recall. This ranges from 0 (bad) to 1 (good): \\(2*\\frac{precision*recall}{precision + recall}\\) = 2*(.2484*.8)/(.2484+.8) = .38 5.2.7.1 Optimal Cutoff Value Often we adjust the cutoff value to improve accuracy. This is where we have to put our gut feeling of what probability constitutes “high risk”. For some models, this could be as low as 30%. It’s whatever the probability is that optimally separates the classes. Let’s look at two ways to visualize model performance as a function of cutoff. 5.2.8 ROC Curves We can create a Receiver operating characteristic (ROC) curve to help find that sweet spot. ROC curves show the balance between sensitivity and specificity. We’ll use the [ROCR] package. It only takes 3 commands: calculate prediction() using the model calculate the model performance() on both true positive rate and true negative rate for a whole range of cutoff values. plot the curve. The colorize option colors the curve according to the probability cutoff point. library(ROCR) pr &lt;- prediction(model.pred.prob, mvmodel$y) perf &lt;- performance(pr, measure=&quot;tpr&quot;, x.measure=&quot;fpr&quot;) plot(perf, colorize=TRUE, lwd=3, print.cutoffs.at=c(seq(0,1,by=0.1))) abline(a=0, b=1, lty=2) We can also use the performance() function and say we want to evaluate the \\(f1\\) measure perf.f1 &lt;- performance(pr,measure=&quot;f&quot;) plot(perf.f1) ROC curves: Can also be used for model comparison: http://yaojenkuo.io/diamondsROC.html The Area under the Curve an give you a measure of overall model accuracy by calculating the area under the curve (auc). auc &lt;- performance(pr, measure=&#39;auc&#39;) auc@y.values ## [[1]] ## [1] 0.695041 "],
["categorical-data.html", "5.3 Categorical Data", " 5.3 Categorical Data Multinomial Regression Ordinal Logistic Regression "],
["count-data.html", "5.4 Count Data", " 5.4 Count Data Lets consider modeling the distribution of the number of of occurrences of a rare event in a specified period of time - e.g. Number of thunderstorms in a year If we assume: Rate (\\(\\mu\\)) is fixed over time Successive occurrences independent of each other Then we can use the Poisson distribution. \\[ P(Y=y) = e^{-\\mu}\\frac{\\mu^{y}}{y!} \\] * The Poisson distribution has a distinct feature where the mean of the distribution \\(\\mu\\), is also the variance. Plot of Histogram of a Poisson Distribution with a Mean of 5 and a Normal Curve 5.4.0.1 Poisson Regression Just another GLM - we use a \\(ln\\) as the link function. \\[ ln(\\mu) = \\mathbf{X}\\beta \\] What actually gets fit, then is: \\[ \\mu = e^{\\mathbf{X}\\beta} \\] This model assumes that the time of “exposure” for each record is identical. - Number of cigarettes per month - Number of epileptic seizures per week If this is not the case (often), then this model needs to include an offset. - e.g. observing each patient for epileptic seizures for a different number of days 5.4.0.2 Example: Modeling counts from the Add Health data Wave IVset. Let’s model the number of siblings someone has, based off their age at Wave 1 (2008). Visualize hist(addhealth$nsib, xlab=&quot;Number of siblings&quot;, ylab=&quot;Count&quot;, main=&quot;&quot;,axes=FALSE, ylim=c(0,3000)) axis(1);axis(2, las=2);box() summary(glm(nsib ~ agew1 + gender, data=addhealth, family=&quot;poisson&quot;)) ## ## Call: ## glm(formula = nsib ~ agew1 + gender, family = &quot;poisson&quot;, data = addhealth) ## ## Deviance Residuals: ## Min 1Q Median 3Q Max ## -2.5489 -1.1666 -0.4465 0.5469 7.0560 ## ## Coefficients: ## Estimate Std. Error z value Pr(&gt;|z|) ## (Intercept) 0.361561 0.099775 3.624 0.00029 *** ## agew1 0.044303 0.005989 7.397 1.39e-13 *** ## genderMale -0.096900 0.019089 -5.076 3.85e-07 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## (Dispersion parameter for poisson family taken to be 1) ## ## Null deviance: 6410.9 on 3917 degrees of freedom ## Residual deviance: 6335.3 on 3915 degrees of freedom ## (2586 observations deleted due to missingness) ## AIC: 16755 ## ## Number of Fisher Scoring iterations: 5 In this case, the exponentiated coefficient is the ratio of the rates of occurrence per unit time Thus, for Poisson regressions, exponentiated coefficients are rate ratios as contrasted with the odds ratios we discussed for logistic regression. Incidence Rate Ratio (IRR): the relative difference measure used to compare the incidence rates of events occurring at any given point in time multivariable : Multiple predictor variables (\\(\\mathbf{x}\\)). multivariate: Multiple response variables (\\(mathbf{Y}\\)). Often analysts will misuse multivaraite when they really mean multivariable. Multivariate techniques are Primarily used as an exploratory technique Restructure interrelated variables Simplify description Reduce dimensionality Avoid multicollinearity problems in regression We will discuss two different, but related techniques: Principal Component Analysis and Factor Analysis. "],
["pca.html", "Chapter 6 Principal Component Analysis", " Chapter 6 Principal Component Analysis More nomenclature tidbits: It’s “Principal” Components (adjective), not “Principle” Components (noun) From Grammerist: As a noun, principal refers to (1) one who holds a presiding position or rank, and (2) capital or property before interest, and it’s also an adjective meaning (3) first or most important in rank Principle is only a noun. In its primary sense, it refers to a basic truth, law, assumption, or rule. This third definition (3) is the context in which we will be using this term. Not variable selection Principal Components Analysis (PCA) differs from variable selection in two ways: No dependent variable exists Variables are not eliminated but rather summary variables, i.e., principal components, are computed from all of the original variables. We are trying to understand a phenomenon by collecting a series of component measurements, but the underlying mechanics is complex and not easily understood by simply looking at each component individually. The data could be redundant and high levels of multicolinearity may be present. "],
["basic-idea.html", "6.1 Basic Idea", " 6.1 Basic Idea Consider a hypothetical data set that consists of 100 random pairs of observations \\(X_{1}\\) and \\(X_{2}\\) that are correlated. Let \\(X_{1} \\sim \\mathcal{N}(100, 100)\\), \\(X_{2} \\sim \\mathcal{N}(50, 50)\\), with \\(\\rho_{12} = \\frac{1}{\\sqrt{2}}\\). In matrix notation this is written as: \\(\\mathbf{X} \\sim \\mathcal{N}\\left(\\mathbf{\\mu}, \\mathbf{\\Sigma}\\right)\\) where \\[\\mathbf{\\mu} = \\left(\\begin{array} {r} \\mu_{1} \\\\ \\mu_{2} \\end{array}\\right), \\mathbf{\\Sigma} = \\left(\\begin{array} {cc} \\sigma_{1}^{2} &amp; \\rho_{12}\\sigma_{x}\\sigma_{y} \\\\ \\rho_{12}\\sigma_{x}\\sigma_{y} &amp; \\sigma_{2}^{2} \\end{array}\\right) \\]. set.seed(456) m &lt;- c(100, 50) s &lt;- matrix(c(100, sqrt(.5*100*50), sqrt(.5*100*50), 50), nrow=2) data &lt;- data.frame(MASS::mvrnorm(n=100, mu=m, Sigma=s)) colnames(data) &lt;- c(&quot;X1&quot;, &quot;X2&quot;) plot(X2 ~ X1, data=data, pch=16) Goal: Create two new variables \\(C_{1}\\) and \\(C_{2}\\) as linear combinations of \\(\\mathbf{x_{1}}\\) and \\(\\mathbf{x_{2}}\\) \\[ \\mathbf{C_{1}} = a_{11}\\mathbf{x_{1}} + a_{12}\\mathbf{x_{2}} \\] \\[ \\mathbf{C_{2}} = a_{21}\\mathbf{x_{1}} + a_{22}\\mathbf{x_{2}} \\] or more simply \\(\\mathbf{C = aX}\\), where The \\(\\mathbf{x}\\)’s have been centered by subtracting their mean (\\(\\mathbf{x_{1}} = x_{1}-\\bar{x_{1}}\\)) \\(Var(C_{1})\\) is as large as possible Graphically we’re creating two new axes, where now \\(C_{1}\\) and \\(C_{2}\\) are uncorrelated. PCA is mathematically defined as an orthogonal linear transformation that transforms the data to a new coordinate system such that the greatest variance by some projection of the data comes to lie on the first coordinate (called the first principal component), the second greatest variance on the second coordinate, and so on. Wikipedia "],
["more-generally.html", "6.2 More Generally", " 6.2 More Generally We want From \\(P\\) original variables \\(X_{1}, \\ldots , X_{P}\\) get \\(P\\) principal components \\(C_{1}, \\ldots , C_{P}\\) Where each \\(C_{j}\\) is a linear combination of the \\(X_{i}\\)’s: \\(C_{j} = a_{j1}X_{1} + a_{j2}X_{2} + \\ldots + a_{jP}X_{P}\\) The coefficients are chosen such that \\(Var(C_{1}) \\geq Var(C_{2}) \\geq \\ldots \\geq Var(C_{P})\\) Variance is a measure of information. Consider modeling prostate cancer. Gender has 0 variance. No information. Size of tumor: the variance is &gt; 0, it provides useful information. Any two PC’s are uncorrelated: \\(Cov(C_{i}, C_{j})=0, \\quad \\forall i \\neq j\\) We have \\[ \\left[ \\begin{array}{r} C_{1} \\\\ C_{2} \\\\ \\vdots \\\\ C_{P} \\end{array} \\right] = \\left[ \\begin{array}{cccc} a_{11} &amp; a_{12} &amp; \\ldots &amp; a_{1P} \\\\ a_{21} &amp; a_{22} &amp; \\ldots &amp; a_{2P} \\\\ \\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots \\\\ a_{P1} &amp; a_{P2} &amp; \\ldots &amp; a_{PP} \\end{array} \\right] \\left[ \\begin{array}{r} X_{1} \\\\ X_{2} \\\\ \\vdots \\\\ X_{P} \\end{array} \\right] \\] Hotelling (1933) showed that the \\(a_{ij}\\)’s are solutions to \\((\\mathbf{\\Sigma} -\\lambda\\mathbf{I})\\mathbf{a}=\\mathbf{0}\\). \\(\\mathbf{\\Sigma}\\) is the variance-covariance matrix of the \\(\\mathbf{X}\\) variables. This means \\(\\lambda\\) is an eigenvalue and \\(\\mathbf{a}\\) an eigenvector. Problem: There are infinite number of possible \\(\\mathbf{a}\\)’s Solution: Choose \\(a_{ij}\\)’s such that the sum of the squares of the coefficients for any one eigenvector is = 1. \\(P\\) unique eigenvalues and \\(P\\) corresponding eigenvectors. So, Principal components are the eigenvectors \\(\\mathbf{a_{p}}\\) and their variances are the eigenvalues of the covariance matrix \\(\\mathbf{\\Sigma}\\) of the \\(X\\)’s. Variances of the \\(C_{j}\\)’s add up to the sum of the variances of the original variables (total variance). "],
["calculating-c.html", "6.3 Calculating C", " 6.3 Calculating C Calculating the principal components in R can be done using a call to the function prcomp(). STHDA has a good overview of the difference between prcomp() and princomp(). pr &lt;- princomp(data) summary(pr) ## Importance of components: ## Comp.1 Comp.2 ## Standard deviation 11.4019265 4.2236767 ## Proportion of Variance 0.8793355 0.1206645 ## Cumulative Proportion 0.8793355 1.0000000 The summary output above shows the first PC (Comp.1) explains the highest proportion of variance. The values for the matrix \\(\\mathbf{A}\\) is contained in pr$loadings. pr$loadings ## ## Loadings: ## Comp.1 Comp.2 ## X1 -0.854 0.519 ## X2 -0.519 -0.854 ## ## Comp.1 Comp.2 ## SS loadings 1.0 1.0 ## Proportion Var 0.5 0.5 ## Cumulative Var 0.5 1.0 To visualize these new axes, we plot the centered data. a &lt;- pr$loadings x1 &lt;- with(data, X1 - mean(X1)) x2 &lt;- with(data, X2 - mean(X2)) plot(c(-40, 40), c(-20, 20), type=&quot;n&quot;,xlab=&quot;x1&quot;, ylab=&quot;x2&quot;) points(x=x1, y=x2, pch=16) abline(0, a[2,1]/a[1,1]); text(30, 10, expression(C[1])) abline(0, a[2,2]/a[1,2]); text(-10, 20, expression(C[2])) Plot the original data on the new axes we see that PC1 and PC2 are uncorrelated. The red vectors show you where the original coordinates were at. biplot(pr) "],
["using-the-correlation-matrix.html", "6.4 Using the correlation matrix", " 6.4 Using the correlation matrix Standardizing: Take \\(X\\) and divide each element by \\(\\sigma_{x}\\). \\(Z = X/\\sigma_{X}\\) Side note: Standardizing and centering == normalizing \\(Z = (X-\\bar{X})/\\sigma_{X}\\) Equivalent to analyzing the correlation matrix (\\(\\mathbf{R}\\)) instead of covariance matrix (\\(\\mathbf{\\Sigma}\\)). Using correlation matrix vs covariance matrix will generate different PC’s This makes sense given the difference in matricies: cov(data) #Covariance Matrix ## X1 X2 ## X1 100.74146 50.29187 ## X2 50.29187 48.59528 cor(data) #Correlation Matrix ## X1 X2 ## X1 1.0000000 0.7187811 ## X2 0.7187811 1.0000000 Standardizing your data prior to analysis aids the interpretation of the PC’s in a few ways The total variance is the number of variables \\(P\\) The proportion explained by each PC is the corresponding eigenvalue / \\(P\\) The correlation between \\(C_{i}\\) and standardized variable \\(x_{j}\\) can be written as \\(r_{ij} = a_{ij}SD(C_{i})\\) This last point means that for any given \\(C_{i}\\) we can quantify the relative degree of dependence of the PC on each of the standardized variables. This is a.k.a. the factor loading (we will return to this key term later). To calculate the principal components using the correlation matrix, you just need to specify that you want cor=TRUE. pr_corr &lt;- princomp(data, cor=TRUE) summary(pr_corr) ## Importance of components: ## Comp.1 Comp.2 ## Standard deviation 1.3110229 0.5303008 ## Proportion of Variance 0.8593906 0.1406094 ## Cumulative Proportion 0.8593906 1.0000000 If we use the covariance matrix and change the scale of a variable (i.e. in to cm) that will change the results of the PC’s Many researchers prefer to use the correlation matrix It compensates for the units of measurements for the different variables. Interpretations are made in terms of the standardized variables. "],
["data-reduction.html", "6.5 Data Reduction", " 6.5 Data Reduction Keep first \\(m\\) principal components as representatives of original P variables Keep enough to explain a large percentage of original total variance. Ideally you want a small number of PC’s that explain a large percentage of the total variance. Choosing \\(m\\) Rely on existing theory Explain a given % of variance (cumulative percentage plot) All eigenvalues &gt; 1 (Scree plot) Elbow rule (Scree Plot) These last two will be best explained using an example. "],
["example-analysis-of-depression.html", "6.6 Example Analysis of depression", " 6.6 Example Analysis of depression This example follows Analysis of depression data set section in PMA5 Section 14.5. This survey asks 20 questions on emotional states that relate to depression. Here I use PCA to reduce these 20 correlated variables down to a few uncorrelated variables that explain the most variance. 1. Read in the data and run princomp on the C1:C20 variables. depress &lt;- read.delim(&quot;https://norcalbiostat.netlify.com/data/depress_081217.txt&quot;, header=TRUE) pc_dep &lt;- princomp(depress[,9:28], cor=TRUE) summary(pc_dep) ## Importance of components: ## Comp.1 Comp.2 Comp.3 Comp.4 ## Standard deviation 2.6562036 1.21883931 1.10973409 1.03232021 ## Proportion of Variance 0.3527709 0.07427846 0.06157549 0.05328425 ## Cumulative Proportion 0.3527709 0.42704935 0.48862483 0.54190909 ## Comp.5 Comp.6 Comp.7 Comp.8 ## Standard deviation 1.00629648 0.98359581 0.97304489 0.87706188 ## Proportion of Variance 0.05063163 0.04837304 0.04734082 0.03846188 ## Cumulative Proportion 0.59254072 0.64091375 0.68825457 0.72671645 ## Comp.9 Comp.10 Comp.11 Comp.12 ## Standard deviation 0.83344885 0.81248191 0.77950975 0.74117295 ## Proportion of Variance 0.03473185 0.03300634 0.03038177 0.02746687 ## Cumulative Proportion 0.76144830 0.79445464 0.82483641 0.85230328 ## Comp.13 Comp.14 Comp.15 Comp.16 ## Standard deviation 0.73255278 0.71324438 0.67149280 0.61252016 ## Proportion of Variance 0.02683168 0.02543588 0.02254513 0.01875905 ## Cumulative Proportion 0.87913496 0.90457083 0.92711596 0.94587501 ## Comp.17 Comp.18 Comp.19 Comp.20 ## Standard deviation 0.56673129 0.54273638 0.51804873 0.445396635 ## Proportion of Variance 0.01605922 0.01472814 0.01341872 0.009918908 ## Cumulative Proportion 0.96193423 0.97666237 0.99008109 1.000000000 2. Pick a subset of PC’s to work with In the cumulative percentage plot below, I drew a horizontal line at 80%. So the first 9 PC’s explain around 75% of the total variance, and the first 10 can explain around 80%. library(ggplot2) qplot(x=1:20, y=cumsum((pc_dep$sdev)^2/20)*100, geom=&quot;point&quot;) + xlab(&quot;PC number&quot;) + ylab(&quot;Cumulative %&quot;) + ylim(c(0,100)) + geom_hline(aes(yintercept=80)) 3. Create a Scree plot by plotting the eigenvalue against the PC number. qplot(x=1:20, y=(pc_dep$sdev)^2, geom=c(&quot;point&quot;, &quot;line&quot;)) + xlab(&quot;PC number&quot;) + ylab(&quot;Eigenvalue&quot;) + ylim(c(0,8)) Option 1: Take all eigenvalues &gt; 1 (\\(m=5\\)) Option 2: Use a cutoff point where the lines joining consecutive points are steep to the left of the cutoff point and flat right of the cutoff point. Point where the two slopes meet is the elbow. (\\(m=2\\)). 4. Examine the loadings pc_dep$loadings[1:3,1:5] ## Comp.1 Comp.2 Comp.3 Comp.4 Comp.5 ## c1 0.2774384 -0.14497938 0.05770239 -0.002723687 -0.08826773 ## c2 0.3131829 0.02713557 0.03162990 0.247811083 -0.02439748 ## c3 0.2677985 -0.15471968 0.03459037 0.247246879 0.21830547 Here \\(X_{1}\\) = “I felt that I could not shake…” \\(X_{2}\\) = “I felt depressed…” So the PC’s are calculated as $C_{1} = 0.277x_{1} + 0.313x_{2} + $ $C_{2} = -0.1449x_{1} + 0.0271x_{2} + $ etc… 5. Interpret the PC’s Visualize the loadings using heatmap.2() in the gplots package. I reversed the colors so that red was high positive correlation and yellow/white is low. half the options I use below come from this SO post. I had no idea what they did, so I took what the solution showed, and played with it (added/changed some to see what they did), and reviewed ?heatmap.2 to see what options were available. library(gplots) heatmap.2(pc_dep$loadings[,1:5], scale=&quot;none&quot;, Rowv=NA, Colv=NA, density.info=&quot;none&quot;, dendrogram=&quot;none&quot;, trace=&quot;none&quot;, col=rev(heat.colors(256))) Loadings over 0.5 (red) help us interpret what these components could “mean” Must know exact wording of component questions \\(C_{1}\\): a weighted average of most items. High value indicates the respondent had many symptoms of depression. Note sign of loadings are all positive and all roughly the same color. Recall \\(C_{2}\\): lethargy (high energetic). High loading on c14, 16, 17, low on 4, 8, 20 \\(C_{3}\\): friendliness of others. Large negative loading on c19, c9 etc. "],
["use-in-multiple-regression.html", "6.7 Use in Multiple Regression", " 6.7 Use in Multiple Regression Choose a handful of few principal components to use as predictors in a regression model Leads to more stable regression estimates. Alternative to variable selection Ex: several measures of behavior. Use PC\\(_{1}\\) or PC\\(_{1}\\) and PC\\(_{2}\\) as summary measures of all. "],
["things-to-watch-out-for.html", "6.8 Things to watch out for", " 6.8 Things to watch out for Eigenvalues are estimated variances of the PC’s and so are subject to large sample variations. The size of variance of last few principal components can be useful as indicator of multicollinearity among original variables Principal components derived from standardized variables differ from those derived from original variables Important that measurements are accurate, especially for detection of collinearity Arbitrary cutoff points should not be taken too seriously "],
["fa.html", "Chapter 7 Factor Analysis", " Chapter 7 Factor Analysis FA is not PCA "],
["stuff.html", "7.1 stuff", " 7.1 stuff "],
["RI.html", "Chapter 8 Random Intercept Models", " Chapter 8 Random Intercept Models Intro "],
["longitudinal.html", "Chapter 9 Longitudinal Data", " Chapter 9 Longitudinal Data Intro on longitudinal data and models "],
["spatial.html", "Chapter 10 Spatial Data", " Chapter 10 Spatial Data Intro on spatial data and models "],
["mda.html", "Chapter 11 Missing Data", " Chapter 11 Missing Data Missing Data happens. Not always General: Item non-response. Individual pieces of data are missing. Unit non-response: Records have some background data on all units, but some units don’t respond to any question. Monotonone missing data: Variables can be ordered such that one block of variables more observed than the next. "],
["identifying-missing-data.html", "11.1 Identifying missing data", " 11.1 Identifying missing data Missing data in R is denoted as NA Arithmetic functions on missing data will return missing survey &lt;- MASS::survey # to avoid loading the MASS library which will conflict with dplyr head(survey$Pulse) ## [1] 92 104 87 NA 35 64 mean(survey$Pulse) ## [1] NA The summary() function will always show missing. summary(survey$Pulse) ## Min. 1st Qu. Median Mean 3rd Qu. Max. NA&#39;s ## 35.00 66.00 72.50 74.15 80.00 104.00 45 The is.na() function is helpful to identify rows with missing data table(is.na(survey$Pulse)) ## ## FALSE TRUE ## 192 45 The function table() will not show NA by default. table(survey$M.I) ## ## Imperial Metric ## 68 141 table(survey$M.I, useNA=&quot;always&quot;) ## ## Imperial Metric &lt;NA&gt; ## 68 141 28 What percent of the data set is missing? round(prop.table(table(is.na(survey)))*100,1) ## ## FALSE TRUE ## 96.2 3.8 4% of the data points are missing. How much missing is there per variable? prop.miss &lt;- apply(survey, 2, function(x) round(sum(is.na(x))/NROW(x),4)) prop.miss ## Sex Wr.Hnd NW.Hnd W.Hnd Fold Pulse Clap Exer Smoke Height ## 0.0042 0.0042 0.0042 0.0042 0.0000 0.1899 0.0042 0.0000 0.0042 0.1181 ## M.I Age ## 0.1181 0.0000 The amount of missing data per variable varies from 0 to 19%. 11.1.1 Visualize missing patterns Using ggplot2 pmpv &lt;- data.frame(variable = names(survey), pct.miss =prop.miss) ggplot(pmpv, aes(x=variable, y=pct.miss)) + geom_bar(stat=&quot;identity&quot;) + ylab(&quot;Percent&quot;) + scale_y_continuous(labels=scales::percent, limits=c(0,1)) + geom_text(data=pmpv, aes(label=paste0(round(pct.miss*100,1),&quot;%&quot;), y=pct.miss+.025), size=4) Using mice library(mice) md.pattern(survey) ## Fold Exer Age Sex Wr.Hnd NW.Hnd W.Hnd Clap Smoke Height M.I Pulse ## 168 1 1 1 1 1 1 1 1 1 1 1 1 0 ## 1 1 1 1 0 1 1 1 1 1 1 1 1 1 ## 1 1 1 1 1 1 1 0 1 1 1 1 1 1 ## 38 1 1 1 1 1 1 1 1 1 1 1 0 1 ## 20 1 1 1 1 1 1 1 1 1 0 0 1 2 ## 1 1 1 1 1 0 0 1 0 1 1 1 1 3 ## 7 1 1 1 1 1 1 1 1 1 0 0 0 3 ## 1 1 1 1 1 1 1 1 1 0 0 0 1 3 ## 0 0 0 1 1 1 1 1 1 28 28 45 107 This somewhat ugly output tells us that 168 records have no missing data, 38 records are missing only Pulse and 20 are missing both Height and M.I. Using VIM library(VIM) aggr(survey, col=c(&#39;chartreuse3&#39;,&#39;mediumvioletred&#39;), numbers=TRUE, sortVars=TRUE, labels=names(survey), cex.axis=.7, gap=3, ylab=c(&quot;Missing data&quot;,&quot;Pattern&quot;)) The plot on the left is a simplified, and ordered version of the ggplot from above, except the bars appear to be inflated because the y-axis goes up to 15% instead of 100%. The plot on the right shows the missing data patterns, and indicate that 71% of the records has complete cases, and that everyone who is missing M.I. is also missing Height. Another plot that can be helpful to identify patterns of missing data is a marginplot (also from VIM). Two continuous variables are plotted against each other. Blue bivariate scatterplot and univariate boxplots are for the observations where values on both variables are observed. Red univariate dotplots and boxplots are drawn for the data that is only observed on one of the two variables in question. The darkred text indicates how many records are missing on both. marginplot(survey[,c(6,10)]) This shows us that the observations missing pulse have the same median height, but those missing height have a higher median pulse rate. "],
["effects-of-nonresponse.html", "11.2 Effects of Nonresponse", " 11.2 Effects of Nonresponse Textbook example: Example reported in W.G. Cochran, Sampling Techniques, 3rd edition, 1977, ch. 13 Consider data that come form an experimental sampling of fruit orcharts in North Carolina in 1946. Three successive mailings of the same questionnaire were sent to growers. For one of the questions the number of fruit trees, complete data were available for the population… Ave. # trees # of growers % of pop’n Ave # trees/grower 1st mailing responders 300 10 456 2nd mailing responders 543 17 382 3rd mailing responders 434 14 340 Nonresponders 1839 59 290 ——– ——– ——– Total population 3116 100 329 The overall response rate was very low. The rate of non response is clearly related to the average number of trees per grower. The estimate of the average trees per grower can be calculated as a weighted average from responders \\(\\bar{Y_{1}}\\) and non responders \\(\\bar{Y_{2}}\\). Bias: The difference between the observed estimate \\(\\bar{y}_{1}\\) and the true parameter \\(\\mu\\). \\[ \\begin{aligned} E(\\bar{y}_{1}) - \\mu &amp; = \\bar{Y_{1}} - \\bar{Y} \\\\ &amp; = \\bar{Y}_{1} - \\left[(1-w)\\bar{Y}_{1} - w\\bar{Y}_{2}\\right] \\\\ &amp; = w(\\bar{Y}_{1} - \\bar{Y}_{2}) \\end{aligned} \\] Where \\(w\\) is the proportion of non-response. The amount of bias is the product of the proportion of non-response and the difference in the means between the responders and the non-responders. The sample provides no information about \\(\\bar{Y_{2}}\\), the size of the bias is generally unknown without information gained from external data. "],
["missing-data-mechanisms.html", "11.3 Missing Data Mechanisms", " 11.3 Missing Data Mechanisms Process by which some units observed, some units not observed Missing Completely at Random (MCAR): The probability that a data point is missing is completely unrelated (independent) of any observed and unobserved data or parameters. P(Y missing| X, Y) = P(Y missing) Ex: Miscoding or forgetting to log in answer Missing at Random (MAR): The probability that a data point is missing is independent can be explained or modeled by other observed variables. P(Y missing|x, Y) = P(Y missing | X) Ex: Y = age, X = sex - Pr (Y miss| X = male) = 0.2 - Pr (Y miss| X = female) = 0.3 - Males people are less likely to fill out an income survey - The missing data on income is related to gender - After accounting for gender the missing data is unrelated to income. Not missing at Random (NMAR): The probability that a data point is missing depends on the value of the variable in question. P(Y missing | X, Y) = P (Y missing|X, Y) Ex: Y = income, X = immigration status Richer person may be less willing to disclose income Illegal immigrant may be less willing to disclose income Does it matter to inferences? Yes! 11.3.1 Demonstration via Simulation 11.3.1.1 MCAR Draw a random sample of size 100 from a standard Normal distribution (Z) and calculate the mean. z &lt;- rnorm(100) mean.z &lt;- mean(z) mean.z ## [1] 0.07627938 Delete data at a rate of \\(p\\) and calculate the complete case (available) mean. Sample 100 random Bernoulli (0/1) variables with probability \\(p\\). x &lt;- rbinom(100, 1, p=.5) Find out which elements are are 1’s delete.these &lt;- which(x==1) Set those elements in z to NA. z[delete.these] &lt;- NA Calculate the complete case mean mean(z, na.rm=TRUE) ## [1] 0.05156296 Calculate the bias mean.z - mean(z, na.rm=TRUE) ## [1] 0.02471642 How does the bias change as a function of the proportion of missing? Let \\(p\\) range from 0% to 99% and plot the bias as a function of \\(p\\). calc.bias &lt;- function(p){ mean.z - mean(ifelse(rbinom(100, 1, p)==1, NA, z), na.rm=TRUE) } p &lt;- seq(0,.99,by=.01) plot(c(0,1), c(-1, 1), type=&quot;n&quot;, ylab=&quot;Bias&quot;, xlab=&quot;Proportion of missing&quot;) points(p, sapply(p, calc.bias), pch=16) abline(h=0, lty=2, col=&quot;blue&quot;) 11.3.1.2 NMAR: Missing related to data What if the rate of missing is related to the value of the outcome? 1. Randomly draw 100 random normal samples. Z &lt;- rnorm(100) Randomly draw 100 uniform random values between 0 and 1 to serve as probabilities. p &lt;- runif(100, 0, 1) Sort both the value of Z and the probability of missingness \\(p\\) in ascending order dta &lt;- data.frame(Z=sort(Z), p=sort(p)) head(dta) ## Z p ## 1 -1.876325 0.0007573694 ## 2 -1.813006 0.0081423270 ## 3 -1.723723 0.0102764855 ## 4 -1.647617 0.0224227244 ## 5 -1.522886 0.0224698714 ## 6 -1.431914 0.0266853301 ggplot(dta, aes(x=p, y=Z)) + geom_point() + xlab(&quot;P(missing)&quot;) + ylab(&quot;Z~Normal(0,1)&quot;) Set \\(Z\\) missing with probability equal to the \\(p\\) for that row. _Create a new vector dta$z.miss that is either 0, or the value of dta$Z with probability 1-dta$p. Then change all the 0’s to NA. dta$Z.miss &lt;- dta$Z * (1-rbinom(NROW(dta), 1, dta$p)) head(dta) ## Z p Z.miss ## 1 -1.876325 0.0007573694 -1.876325 ## 2 -1.813006 0.0081423270 -1.813006 ## 3 -1.723723 0.0102764855 -1.723723 ## 4 -1.647617 0.0224227244 -1.647617 ## 5 -1.522886 0.0224698714 -1.522886 ## 6 -1.431914 0.0266853301 -1.431914 dta$Z.miss[dta$Z.miss==0] &lt;- NA Calculate the complete case mean and the bias mean(dta$Z.miss, na.rm=TRUE) ## [1] -0.6020052 mean(dta$Z) - mean(dta$Z.miss, na.rm=TRUE) ## [1] 0.5910749 11.3.1.3 NMAR: Pure Censoring Consider a hypothetical blood test to measure a hormone that is normally distributed in the blood with mean 10\\(\\mu g\\) and variance 1. However the test to detect the compound only can detect levels above 10. z &lt;- rnorm(100, 10, 1) y &lt;- z y[y&lt;10] &lt;- NA mean(y, na.rm=TRUE) ## [1] 10.87093 When the data is not missing at random, the bias can be much greater. Problem: Usually you don’t know the missing data mechanism. Degrees of difficulty MCAR is easiest to deal with. MAR: we can live with it. NMAR: most difficult to handle. Evidence? What can we learn from evidence in the data set at hand? May be evidence in the data rule out MCAR - test responders vs. nonresponders. Example: Responders tend to have higher/lower average education than nonresponders by t-test Example: Response more likely in one geographic area than another by chi-square test No evidence in data set to rule out MAR (although there may be evidence from an external data source) What is plausible? Cochran example: when human behavior is involved, MCAR must be viewed as an extremely special case that would often be violated in practice Missing data may be introduced by design (e.g., measure some variables, don’t measure others for reasons of cost, response burden), in which case MCAR would apply MAR is much more common than MCAR We cannot be too cavalier about assuming MAR, but anecdotal evidence shows that it often is plausible when conditioning on enough information Ignorable Missing If missing-data mechanism is MCAR or MAR then nonresponse is said to be “ignorable” Origin of name: in likelihood-based inference, both the data model and missing-data mechanism are important but with MCAR or MAR, inference can be based solely on the data model, thus making inference much simpler “Ignorability” is a relative assumption: missingness on income may be NMAR given only gender, but may be MAR given gender, age, occupation, region of the country "],
["general-strategies.html", "11.4 General strategies", " 11.4 General strategies Strategies for handling missing data include: Complete-case/available-case analysis: drop cases that make analysis inconvenient Imputation procedures: fill in missing values, then analyze completed data sets using complete-date methods Weighting procedures: modify “design weights” (i.e., inverse probabilities of selection from sampling plan) to account for probability of response Model-based approaches: develop model for partially missing data, base inferences on likelihood under that model 11.4.1 Complete cases analysis If not all variables observed, delete case from analysis Advantages: Simplicity Common sample for all estimates Disadvantages: Loss of information, e.g., if there are 20 variables, each 10% missing MCAR, then expect 12% complete cases (0.92 -0.12) Bias due to violation of MCAR 11.4.2 Available-case analysis Use all cases where the variable of interest is present Potentially different sets of cases for means of X and Y and complete pairs for \\(r_{XY}\\) Tempting to think that available-case analysis will be superior to complete-case analysis But it can distort relationships between variables by not using a common base of observations for all quantities being estimated. 11.4.3 Imputation Fill in missing values, analyze completed data set Advantage: Rectangular data set easier to analyze Disadvantage: “Both seductive and dangerous”&quot; (Little and Rubin) Can understate uncertainty due to missing values. Can induce bias if imputing under the wrong model. "],
["imputation-methods.html", "11.5 Imputation Methods", " 11.5 Imputation Methods Unconditional mean substitution. Never use Impute all missing data using the mean of observed cases Highly biased Artificially decreases the mean. Hot deck imputation Impute values by randomly sampling values from observed data. Good for categorical data Reasonable for MCAR and MAR Model based imputation Conditional Mean imputation: Use regression on observed variables to estimate missing values Predictive Mean Matching: Fills in a value randomly by sampling observed values whose regression-predicted values are closest to the regression-predicted value for the missing point. Cross between hot-deck and conditional mean Categorical data can be imputed using classification models Less biased than mean substitution but SE’s could be inflated Adding a residual Impute regression value \\(\\pm\\) a randomly selected residual based on estimated residual variance Over the long-term, we can reduce bias, on the average …but we can do better. "],
["multiple-imputation-mi.html", "11.6 Multiple Imputation (MI)", " 11.6 Multiple Imputation (MI) 11.6.1 Goals Accurately reflect available information Avoid bias in estimates of quantities of interest Estimation could involve explicit or implicit model Accurately reflect uncertainty due to missingness 11.6.2 Technique For each missing value, impute \\(m\\) estimates (usually \\(m\\) = 5) Imputation method must include a random component Create \\(m\\) complete data sets Perform desired analysis on each of the \\(m\\) complete data sets Combine final estimates in a manner that accounts for the between, and within imputation variance. 11.6.3 MI as a paradigm Logic: “Average over” uncertainty, don’t assume most likely scenario (single imputation) covers all plausible scenarios Principle: Want nominal 95% intervals to cover targets of estimation 95% of the time Simulation studies show that, when MAR assumption holds: Proper imputations will yield close to nominal coverage (Rubin 87) Improvement over single imputation is meaningful Number of imputations can be modest - even 2 adequate for many purposes, so 5 is plenty Rubin 87: Multiple Imputation for Nonresponse in Surveys, Wiley, 1987). 11.6.4 Inference on MI Consider \\(m\\) imputed data sets. For some quantity of interest \\(Q\\) with squared \\(SE = U\\), calculate \\(Q_{1}, Q_{2}, \\ldots, Q_{m}\\) and \\(U_{1}, U_{2}, \\ldots, U_{m}\\) (e.g., carry out \\(m\\) regression analyses, obtain point estimates and SE from each). Then calculate the average estimate \\(\\bar{Q}\\), the average variance \\(\\bar{U}\\), and the variance of the averages \\(B\\). \\[ \\begin{aligned} \\bar{Q} &amp; = \\sum^{m}_{i=1}Q_{i}/m \\\\ \\bar{U} &amp; = \\sum^{m}_{i=1}U_{i}/m \\\\ B &amp; = \\frac{1}{m-1}\\sum^{m}_{i=1}(Q_{i}-\\bar{Q})^2 \\end{aligned} \\] Then \\(T = \\bar{U} + \\frac{m+1}{m}B\\) is the estimated total variance of \\(\\bar{Q}\\). Significance tests and interval estimates can be based on \\[\\frac{\\bar{Q}-Q}{\\sqrt{T}} \\sim t_{df}, \\mbox{ where } df = (m-1)(1+\\frac{1}{m+1}\\frac{\\bar{U}}{B})^2\\] df are similar to those for comparison of normal means with unequal variances, i.e., using Satterthwaite approximation. Ratio of (B = between-imputation variance) to (T = between + within-imputation variance) is known as the fraction of missing information. "],
["multiple-imputation-using-chained-equations-mice.html", "11.7 Multiple Imputation using Chained Equations (MICE)", " 11.7 Multiple Imputation using Chained Equations (MICE) Generates multiple imputations for incomplete multivariate data by Gibbs sampling. Missing data can occur anywhere in the data. Impute an incomplete column by generating ‘plausible’ synthetic values given other columns in the data. For predictors that are incomplete themselves, the most recently generated imputations are used to complete the predictors prior to imputation of the target column. A separate univariate imputation model can be specified for each column. The default imputation method depends on the measurement level of the target column. Consider a data matrix with 3 variables \\(y_{1}\\), \\(y_{2}\\), \\(y_{3}\\), each with missing values. At iteration \\((\\ell)\\): Fit a model on \\(y_{1}^{(\\ell-1)}\\) using current values of \\(y_{2}^{(\\ell-1)}, y_{3}^{(\\ell-1)}\\) Impute missing \\(y_{1}\\), generating \\(y_{1}^{(\\ell)}\\) Fit a model on \\(y_{2}^{(\\ell-1)}\\) using current versions of \\(y_{1}^{(\\ell)}, y_{3}^{(\\ell-1)}\\) Impute missing \\(y_{2}\\), generating \\(y_{2}^{(\\ell)}\\) Fit a model on \\(y_{3}\\) using current versions of \\(y_{1}^{(\\ell)}, y_{2}^{(\\ell)}\\) Impute missing \\(y_{3}\\), generating \\(y_{3}^{(\\ell)}\\) Start next cycle using updated values \\(y_{1}^{(\\ell)}, y_{2}^{(\\ell)}, y_{3}^{(\\ell)}\\) (Select) Built-in elementary imputation methods are: pmm: Predictive mean matching (any) DEFAULT FOR NUMERIC norm.nob: Linear regression ignoring model error (numeric) norm.boot: Linear regression using bootstrap (numeric) norm.predict: Linear regression, predicted values (numeric) mean: Unconditional mean imputation (numeric) logreg: Logistic regression (factor, 2 levels) DEFAULT logreg.boot: Logistic regression with bootstrap polyreg: Polytomous logistic regression (factor, &gt;= 2 levels) DEFAULT lda: Linear discriminant analysis (factor, &gt;= 2 categories) cart: Classification and regression trees (any) rf: Random forest imputations (any) 11.7.0.1 Example: Prescribed amount of missing. We will demonstrate using Fisher’s Iris data (pre-built in with R) where we can artificially create a prespecified percent of the data missing. This allows us to be able to estimate the bias incurred by using these imputation methods. For the iris data we set a seed and use the prodNA() function from the missForest package to create 10% missing values in this data set. library(missForest) prop.table(table(is.na(iris))) ## ## FALSE ## 1 set.seed(12345) # Note to self: Change the combo on my luggage iris.mis &lt;- prodNA(iris, noNA=0.1) prop.table(table(is.na(iris.mis))) ## ## FALSE TRUE ## 0.9 0.1 11.7.0.2 Multiply impute the missing data using mice() imp_iris &lt;- mice(iris.mis, m=5, maxit=20, meth=&quot;pmm&quot;, seed=500, printFlag=FALSE) summary(imp_iris) ## Multiply imputed data set ## Call: ## mice(data = iris.mis, m = 5, method = &quot;pmm&quot;, maxit = 20, printFlag = FALSE, ## seed = 500) ## Number of multiple imputations: 5 ## Missing cells per column: ## Sepal.Length Sepal.Width Petal.Length Petal.Width Species ## 16 15 13 16 15 ## Imputation methods: ## Sepal.Length Sepal.Width Petal.Length Petal.Width Species ## &quot;pmm&quot; &quot;pmm&quot; &quot;pmm&quot; &quot;pmm&quot; &quot;pmm&quot; ## VisitSequence: ## Sepal.Length Sepal.Width Petal.Length Petal.Width Species ## 1 2 3 4 5 ## PredictorMatrix: ## Sepal.Length Sepal.Width Petal.Length Petal.Width Species ## Sepal.Length 0 1 1 1 1 ## Sepal.Width 1 0 1 1 1 ## Petal.Length 1 1 0 1 1 ## Petal.Width 1 1 1 0 1 ## Species 1 1 1 1 0 ## Random generator seed value: 500 The method can be either a single string, or a vector of strings with length ncol(data) specifying the elementary imputation method to be used for each column in data. If specified as a single string, the same method will be used for all columns. Columns that need not be imputed have the empty method ’’ printFlag: Use print=FALSE for silent computation. Read 4.3: Assessing Convergence in the JSS article on mice 11.7.0.3 Check the imputation method used on each variable. imp_iris$meth ## Sepal.Length Sepal.Width Petal.Length Petal.Width Species ## &quot;pmm&quot; &quot;pmm&quot; &quot;pmm&quot; &quot;pmm&quot; &quot;pmm&quot; 11.7.0.4 Look at the values generated for imputation This just shows what values were imputed for this variable at each imputation. imp_iris$imp$Sepal.Length ## 1 2 3 4 5 ## 1 5.0 5.0 5.0 5.8 5.2 ## 5 5.6 5.0 5.4 4.8 5.8 ## 26 5.1 4.9 5.1 5.0 5.5 ## 31 5.1 5.0 5.1 4.7 5.5 ## 33 5.5 5.7 5.5 5.8 4.9 ## 39 4.9 4.4 4.4 4.8 4.6 ## 43 5.0 4.9 4.3 4.6 4.6 ## 56 6.6 5.8 6.1 5.6 6.1 ## 96 6.2 6.2 5.8 6.7 6.6 ## 103 6.3 6.3 6.7 6.7 7.2 ## 113 6.3 6.7 6.9 6.9 6.7 ## 124 6.6 5.6 6.4 6.2 6.2 ## 132 7.2 7.7 7.7 7.7 7.7 ## 135 7.7 6.9 6.3 6.7 6.3 ## 149 7.0 6.7 6.7 6.3 6.7 ## 150 6.3 6.4 6.7 7.2 6.4 11.7.0.5 Create a complete data set by filling in the missing data using the imputations iris_1 &lt;- complete(imp_iris, action=1) Action=1 returns the first completed data set, action=2 returns the second completed data set, and so on. 11.7.0.6 Alternative - Stack the imputed data sets in long format. iris_long &lt;- complete(imp_iris, &#39;long&#39;) By looking at the names of this new object we can confirm that there are indeed 5 complete data sets with \\(n=150\\) in each. names(iris_long) ## [1] &quot;.imp&quot; &quot;.id&quot; &quot;Sepal.Length&quot; &quot;Sepal.Width&quot; ## [5] &quot;Petal.Length&quot; &quot;Petal.Width&quot; &quot;Species&quot; table(iris_long$.imp) ## ## 1 2 3 4 5 ## 150 150 150 150 150 11.7.1 Visualize Imputations Let’s compare the imputed values to the observed values to see if they are indeed “plausible” We want to see that the distribution of of the magenta points (imputed) matches the distribution of the blue ones (observed). Univariately densityplot(imp_iris) Multivariately xyplot(imp_iris, Sepal.Length ~ Sepal.Width + Petal.Length + Petal.Width | Species, cex=.8, pch=16) Analyze and pool All of this imputation was done so we could actually perform an analysis! Let’s run a simple linear regression on Sepal.Length as a function of Sepal.Width, Petal.Length and Species. model &lt;- with(imp_iris, lm(Sepal.Length ~ Sepal.Width + Petal.Length + Species)) summary(pool(model)) ## est se t df Pr(&gt;|t|) ## (Intercept) 2.4424312 0.29430137 8.299082 81.52267 1.851852e-12 ## Sepal.Width 0.4574809 0.09086928 5.034495 85.27283 2.636929e-06 ## Petal.Length 0.7058246 0.07676480 9.194639 39.26328 2.448841e-11 ## Species2 -0.7728084 0.24720667 -3.126163 56.48034 2.796938e-03 ## Species3 -1.1255913 0.34481260 -3.264357 36.94475 2.368406e-03 ## lo 95 hi 95 nmis fmi lambda ## (Intercept) 1.8569206 3.0279417 NA 0.1506633 0.1300790 ## Sepal.Width 0.2768168 0.6381451 15 0.1424999 0.1226211 ## Petal.Length 0.5505864 0.8610627 13 0.2890890 0.2537759 ## Species2 -1.2679300 -0.2776869 NA 0.2176870 0.1904668 ## Species3 -1.8242833 -0.4268994 NA 0.3017982 0.2649972 Pooled parameter estimates \\(\\bar{Q}\\) and their standard errors \\(\\sqrt{T}\\) are provided, along with a significance test (against \\(\\beta_p=0\\)), and a 95% interval. Additional information included in this table is the number of missing values, the fraction of missing information (fmi) as defined by Rubin (1987), and lambda, the proportion of total variance that is attributable to the missing data (\\(\\lambda = (B + B/m)/T)\\). kable(summary(pool(model))[,c(1:3, 5:7, 9)], digits=3) est se t Pr(&gt;|t|) lo 95 hi 95 fmi (Intercept) 2.442 0.294 8.299 0.000 1.857 3.028 0.151 Sepal.Width 0.457 0.091 5.034 0.000 0.277 0.638 0.142 Petal.Length 0.706 0.077 9.195 0.000 0.551 0.861 0.289 Species2 -0.773 0.247 -3.126 0.003 -1.268 -0.278 0.218 Species3 -1.126 0.345 -3.264 0.002 -1.824 -0.427 0.302 11.7.2 Calculating bias The iris data set had no missing data to begin with. So we can calculate the “true” parameter estimates… true.model &lt;- lm(Sepal.Length ~ Sepal.Width + Petal.Length + Species, data=iris) and find the difference in coefficients. The variance of the multiply imputed estimates is larger because of the between-imputation variance. "],
["final-thoughts.html", "11.8 Final thoughts", " 11.8 Final thoughts “In our experience with real and artificial data…, the practical conclusion appears to be that multiple imputation, when carefully done, can be safely used with real problems even when the ultimate user may be applying models or analyses not contemplated by the imputer.” - Little &amp; Rubin (Book, p. 218) Don’t ignore missing data. Impute sensibly and multiple times. It’s typically desirable to include many predictors in an imputation model, both to improve precision of imputed values make MAR assumption more plausible But the number of covariance parameters goes up as the square of the number of variables in the model, implying practical limits on the number of variables for which parameters can be estimated well MI applies to subjects who have a general missingness pattern, i.e., they have measurements on some variables, but not on others. But, subjects can be lost to follow up due to death or other reasons (i.e., attrition). Here we have only baseline data, but not the outcome or other follow up data. If attrition subjects are eliminated from the sample, they can produce non-response or attrition bias. Use attrition weights. Given a baseline profile, predict the probability that subject will stay and use the inverse probability as weight. e.g., if for a given profile all subjects stay, then the predicted probability is 1 and the attrition weight is 1. Such a subject “counts once”. For another profile, the probability may be 0.5, attrition weight is 1/.5 = 2 and that person “counts twice”. For differential drop-out, or self-selected treatment, you can consider using Propensity Scores. "],
["additional-references.html", "11.9 Additional References", " 11.9 Additional References Little, R. and Rubin, D. Statistical Analysis with Missing Data, 2nd Ed., Wiley, 2002 Standard reference Requires some math Allison, P. Missing Data, Sage, 2001 Small and cheap Requires very little math Multiple Imputation.com http://www.stefvanbuuren.nl/mi/ mice: Multivariate Imputation by Chained Equations in R (skim) https://www.jstatsoft.org/article/view/v045i03 http://www.analyticsvidhya.com/blog/2016/03/tutorial-powerful-packages-imputing-missing-values/ http://www.r-bloggers.com/imputing-missing-data-with-r-mice-package/ A more in-depth tutorial on these packages can be found at http://www.analyticsvidhya.com/blog/2016/03/tutorial-powerful-packages-imputing-missing-values/ Imputation methods for complex survey data and data not missing at random is an open research topic. Read more about this here: https://support.sas.com/documentation/cdl/en/statug/63033/HTML/default/viewer.htm#statug_mi_sect032.htm "]
]
